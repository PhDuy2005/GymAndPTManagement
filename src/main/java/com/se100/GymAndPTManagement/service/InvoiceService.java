/**
 * Generated by: GitHub Copilot (Claude Haiku 4.5)
 * Created by: KStuv
 * Created at: 2026-01-16
 * Purpose: Service layer for invoice operations including additional service invoices
 */
package com.se100.GymAndPTManagement.service;

import com.se100.GymAndPTManagement.domain.requestDTO.ReqCreateAdditionalServiceInvoiceDTO;
import com.se100.GymAndPTManagement.domain.requestDTO.ReqUpdateInvoiceDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResInvoiceDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResInvoiceDetailDTO;
import com.se100.GymAndPTManagement.domain.table.Invoice;
import com.se100.GymAndPTManagement.domain.table.InvoiceDetail;
import com.se100.GymAndPTManagement.domain.table.Member;
import com.se100.GymAndPTManagement.domain.table.AdditionalService;
import com.se100.GymAndPTManagement.domain.table.ServicePackage;
import com.se100.GymAndPTManagement.repository.InvoiceRepository;
import com.se100.GymAndPTManagement.repository.InvoiceDetailRepository;
import com.se100.GymAndPTManagement.repository.MemberRepository;
import com.se100.GymAndPTManagement.repository.AdditionalServiceRepository;
import com.se100.GymAndPTManagement.repository.ServicePackageRepository;
import com.se100.GymAndPTManagement.util.enums.PaymentStatusEnum;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class InvoiceService {
    
    private static final Logger logger = LoggerFactory.getLogger(InvoiceService.class);
    
    private final InvoiceRepository invoiceRepository;
    private final InvoiceDetailRepository invoiceDetailRepository;
    private final MemberRepository memberRepository;
    private final AdditionalServiceRepository additionalServiceRepository;
    private final ServicePackageRepository servicePackageRepository;
    
    public InvoiceService(InvoiceRepository invoiceRepository,
                         InvoiceDetailRepository invoiceDetailRepository,
                         MemberRepository memberRepository,
                         AdditionalServiceRepository additionalServiceRepository,
                         ServicePackageRepository servicePackageRepository) {
        this.invoiceRepository = invoiceRepository;
        this.invoiceDetailRepository = invoiceDetailRepository;
        this.memberRepository = memberRepository;
        this.additionalServiceRepository = additionalServiceRepository;
        this.servicePackageRepository = servicePackageRepository;
    }
    
    @Transactional
    public ResInvoiceDTO createInvoiceForAdditionalService(
            ReqCreateAdditionalServiceInvoiceDTO request) {
        
        logger.info("Creating invoice for additional service ID: {}, Member ID: {}, Quantity: {}",
                   request.getAdditionalServiceId(), request.getMemberId(), request.getQuantity());
        
        // Step 1: Fetch and validate member
        Member member = memberRepository.findById(request.getMemberId())
            .orElseThrow(() -> {
                logger.error("Member not found with ID: {}", request.getMemberId());
                return new IllegalArgumentException("Member not found with ID: " + request.getMemberId());
            });
        
        // Step 2: Fetch and validate additional service
        AdditionalService additionalService = additionalServiceRepository.findById(request.getAdditionalServiceId())
            .orElseThrow(() -> {
                logger.error("Additional service not found with ID: {}", request.getAdditionalServiceId());
                return new IllegalArgumentException("Additional service not found with ID: " + request.getAdditionalServiceId());
            });
        
        // Step 3: Validate additional service is active
        if (!additionalService.getIsActive()) {
            logger.warn("Additional service is not active. ID: {}", request.getAdditionalServiceId());
            throw new IllegalArgumentException("Additional service is not active");
        }
        
        // Step 4: Validate quantity
        if (request.getQuantity() <= 0) {
            logger.warn("Invalid quantity: {}", request.getQuantity());
            throw new IllegalArgumentException("Quantity must be greater than 0");
        }
        
        // Step 5: Get unit price from service (suggestSellPrice)
        BigDecimal unitPrice = additionalService.getSuggestSellPrice();
        if (unitPrice == null || unitPrice.compareTo(BigDecimal.ZERO) < 0) {
            logger.warn("Invalid price for additional service ID: {}, Price: {}", 
                       request.getAdditionalServiceId(), unitPrice);
            throw new IllegalArgumentException("Additional service has invalid price");
        }
        
        // Step 6: Calculate total amount (quantity × suggestSellPrice)
        BigDecimal totalAmount = unitPrice.multiply(new BigDecimal(request.getQuantity()));
        logger.debug("Invoice calculation - Quantity: {}, Unit Price: {}, Total Amount: {}",
                    request.getQuantity(), unitPrice, totalAmount);
        
        // Step 7: Get discount (default 0 if null)
        BigDecimal discountAmount = request.getDiscountAmount() != null 
            ? request.getDiscountAmount() 
            : BigDecimal.ZERO;
        
        // Step 8: Validate discount is not greater than total
        if (discountAmount.compareTo(totalAmount) > 0) {
            logger.warn("Discount amount {} exceeds total amount {}", discountAmount, totalAmount);
            throw new IllegalArgumentException("Discount amount cannot exceed total amount");
        }
        
        // Step 9: Calculate final amount
        BigDecimal finalAmount = totalAmount.subtract(discountAmount);
        
        // Step 10: Create Invoice Entity
        Invoice invoice = Invoice.builder()
            .member(member)
            .totalAmount(totalAmount)
            .discountAmount(discountAmount)
            .finalAmount(finalAmount)
            .paymentMethod(request.getPaymentMethod())
            .paymentStatus(PaymentStatusEnum.UNPAID)  // Default UNPAID
            .status("ISSUED")  // Invoice issued
            .build();
        
        // Step 11: Save invoice
        Invoice savedInvoice = invoiceRepository.save(invoice);
        logger.info("Invoice created successfully. Invoice ID: {}, Final Amount: {}, Payment Status: {}",
                   savedInvoice.getId(), finalAmount, PaymentStatusEnum.UNPAID);
        
        // Step 12: Create InvoiceDetail for additional service
        InvoiceDetail invoiceDetail = InvoiceDetail.builder()
            .invoice(savedInvoice)
            .servicePackage(null)  // No service package for additional service invoice
            .additionalService(additionalService)
            .quantity(request.getQuantity())
            .unitPrice(unitPrice)
            .totalAmount(totalAmount)  // Total amount = quantity × unitPrice
            .build();
        
        // Step 13: Save invoice detail
        InvoiceDetail savedDetail = invoiceDetailRepository.save(invoiceDetail);
        logger.info("InvoiceDetail created for Invoice ID: {}, Additional Service ID: {}, Amount: {}",
                   savedInvoice.getId(), additionalService.getId(), totalAmount);
        
        // Step 14: Build response DTO
        List<ResInvoiceDetailDTO> details = List.of(mapInvoiceDetailToDTO(savedDetail));
        logger.info("Invoice creation workflow completed successfully for Invoice ID: {}", savedInvoice.getId());
        
        return mapInvoiceToDTO(savedInvoice, details);
    }
    
    public ResInvoiceDTO getInvoiceById(Long invoiceId) {
        logger.debug("Fetching invoice with ID: {}", invoiceId);
        
        Invoice invoice = invoiceRepository.findById(invoiceId)
            .orElseThrow(() -> {
                logger.error("Invoice not found with ID: {}", invoiceId);
                return new IllegalArgumentException("Invoice not found with ID: " + invoiceId);
            });
        
        List<InvoiceDetail> details = invoiceDetailRepository.findByInvoiceId(invoiceId);
        List<ResInvoiceDetailDTO> detailDTOs = details.stream()
            .map(this::mapInvoiceDetailToDTO)
            .collect(Collectors.toList());
        
        return mapInvoiceToDTO(invoice, detailDTOs);
    }
    
    public List<ResInvoiceDTO> getInvoicesByMemberId(Long memberId) {
        logger.debug("Fetching invoices for member ID: {}", memberId);
        
        // Verify member exists
        memberRepository.findById(memberId)
            .orElseThrow(() -> {
                logger.error("Member not found with ID: {}", memberId);
                return new IllegalArgumentException("Member not found with ID: " + memberId);
            });
        
        List<Invoice> invoices = invoiceRepository.findByMemberId(memberId);
        
        return invoices.stream()
            .map(invoice -> {
                List<InvoiceDetail> details = invoiceDetailRepository.findByInvoiceId(invoice.getId());
                List<ResInvoiceDetailDTO> detailDTOs = details.stream()
                    .map(this::mapInvoiceDetailToDTO)
                    .collect(Collectors.toList());
                return mapInvoiceToDTO(invoice, detailDTOs);
            })
            .collect(Collectors.toList());
    }
    
    @Transactional(readOnly = true)
    public List<ResInvoiceDTO> getAllInvoices() {
        logger.debug("Fetching all invoices");
        
        List<Invoice> invoices = invoiceRepository.findAll();
        
        return invoices.stream()
            .map(invoice -> {
                List<InvoiceDetail> details = invoiceDetailRepository.findByInvoiceId(invoice.getId());
                List<ResInvoiceDetailDTO> detailDTOs = details.stream()
                    .map(this::mapInvoiceDetailToDTO)
                    .collect(Collectors.toList());
                return mapInvoiceToDTO(invoice, detailDTOs);
            })
            .collect(Collectors.toList());
    }
    
    @Transactional
    public ResInvoiceDTO updatePaymentStatus(Long invoiceId, PaymentStatusEnum newStatus) {
        logger.info("Updating payment status for invoice ID: {} to {}", invoiceId, newStatus);
        
        Invoice invoice = invoiceRepository.findById(invoiceId)
            .orElseThrow(() -> {
                logger.error("Invoice not found with ID: {}", invoiceId);
                return new IllegalArgumentException("Invoice not found with ID: " + invoiceId);
            });
        
        PaymentStatusEnum oldStatus = invoice.getPaymentStatus();
        invoice.setPaymentStatus(newStatus);
        Invoice updatedInvoice = invoiceRepository.save(invoice);
        
        logger.info("Payment status updated for Invoice ID: {}, From: {} to: {}",
                   invoiceId, oldStatus, newStatus);
        
        List<InvoiceDetail> details = invoiceDetailRepository.findByInvoiceId(invoiceId);
        List<ResInvoiceDetailDTO> detailDTOs = details.stream()
            .map(this::mapInvoiceDetailToDTO)
            .collect(Collectors.toList());
        
        return mapInvoiceToDTO(updatedInvoice, detailDTOs);
    }
    
    /**
     * Map InvoiceDetail entity to response DTO
     */
    private ResInvoiceDetailDTO mapInvoiceDetailToDTO(InvoiceDetail invoiceDetail) {
        if (invoiceDetail == null) {
            return null;
        }
        
        // Validate required relationships
        if (invoiceDetail.getInvoice() == null) {
            throw new IllegalStateException("InvoiceDetail invoice is null");
        }
        
        String servicePackageName = null;
        Long servicePackageId = null;
        if (invoiceDetail.getServicePackage() != null) {
            servicePackageId = invoiceDetail.getServicePackage().getId();
            servicePackageName = invoiceDetail.getServicePackage().getPackageName();
        }
        
        String additionalServiceName = null;
        Long additionalServiceId = null;
        if (invoiceDetail.getAdditionalService() != null) {
            additionalServiceId = invoiceDetail.getAdditionalService().getId();
            additionalServiceName = invoiceDetail.getAdditionalService().getName();
        }
        
        return ResInvoiceDetailDTO.builder()
            .detailId(invoiceDetail.getId())
            .invoiceId(invoiceDetail.getInvoice().getId())
            .servicePackageId(servicePackageId)
            .servicePackageName(servicePackageName)
            .additionalServiceId(additionalServiceId)
            .additionalServiceName(additionalServiceName)
            .quantity(invoiceDetail.getQuantity())
            .unitPrice(invoiceDetail.getUnitPrice())
            .totalAmount(invoiceDetail.getTotalAmount())
            .createdAt(invoiceDetail.getCreatedAt())
            .build();
    }
    
    /**
     * Delete invoice by ID (also deletes associated invoice details)
     * This method implements cascade delete to remove all invoice details first,
     * then delete the invoice itself
     * 
     * @param invoiceId - Invoice ID to delete
     * @throws IllegalArgumentException if invoice not found
     */
    @Transactional
    public void deleteInvoice(Long invoiceId) {
        logger.info("Deleting invoice ID: {}", invoiceId);
        
        Invoice invoice = invoiceRepository.findById(invoiceId)
            .orElseThrow(() -> {
                logger.error("Invoice not found with ID: {}", invoiceId);
                return new IllegalArgumentException("Invoice not found with ID: " + invoiceId);
            });
        
        // Step 1: Delete all invoice details associated with this invoice
        List<InvoiceDetail> invoiceDetails = invoiceDetailRepository.findByInvoiceId(invoiceId);
        if (!invoiceDetails.isEmpty()) {
            logger.info("Deleting {} invoice details for invoice ID: {}", invoiceDetails.size(), invoiceId);
            invoiceDetailRepository.deleteAll(invoiceDetails);
        }
        
        // Step 2: Delete the invoice itself
        invoiceRepository.delete(invoice);
        logger.info("Invoice deleted successfully with ID: {}", invoiceId);
    }

    /**
     * Update invoice information with cascade update to invoice details
     * 
     * Validation rules:
     * 1. Invoice must exist
     * 2. Member must exist
     * 3. Discount amount must be >= 0
     * 4. Invoice details must not be empty
     * 5. For each detail: calculate total amount (quantity × unitPrice)
     * 6. Calculate invoice totals: sum of detail totals - discount
     * 
     * @param invoiceId Invoice ID to update
     * @param request Update request with invoice and detail information
     * @return Updated invoice response DTO
     * @throws IllegalArgumentException if validation fails
     */
    @Transactional
    public ResInvoiceDTO updateInvoice(Long invoiceId, ReqUpdateInvoiceDTO request) {
        logger.info("Updating invoice ID: {}", invoiceId);
        
        // Step 1: Fetch and validate invoice exists
        Invoice invoice = invoiceRepository.findById(invoiceId)
                .orElseThrow(() -> {
                    logger.error("Invoice not found with ID: {}", invoiceId);
                    return new IllegalArgumentException("Invoice not found with ID: " + invoiceId);
                });
        
        // Step 2: Validate member exists
        Member member = memberRepository.findById(request.getMemberId())
                .orElseThrow(() -> {
                    logger.error("Member not found with ID: {}", request.getMemberId());
                    return new IllegalArgumentException("Member not found with ID: " + request.getMemberId());
                });
        
        // Step 3: Validate discount amount
        if (request.getDiscountAmount() == null || request.getDiscountAmount().compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Chiết khấu phải >= 0");
        }
        
        // Step 4: Validate invoice details not empty
        if (request.getDetails() == null || request.getDetails().isEmpty()) {
            throw new IllegalArgumentException("Chi tiết hóa đơn không được để trống");
        }
        
        // Step 5: Delete existing invoice details and create new ones
        List<InvoiceDetail> existingDetails = invoiceDetailRepository.findByInvoiceId(invoiceId);
        invoiceDetailRepository.deleteAll(existingDetails);
        logger.info("Deleted {} existing invoice details for invoice ID: {}", existingDetails.size(), invoiceId);
        
        // Step 6: Create and save new invoice details, calculate totals
        BigDecimal totalAmount = BigDecimal.ZERO;
        List<InvoiceDetail> newDetails = new ArrayList<>();
        
        for (ReqUpdateInvoiceDTO.ReqUpdateInvoiceDetailDTO detailRequest : request.getDetails()) {
            // Validate detail data
            if (detailRequest.getQuantity() <= 0) {
                throw new IllegalArgumentException("Số lượng phải lớn hơn 0");
            }
            if (detailRequest.getUnitPrice() == null || detailRequest.getUnitPrice().compareTo(BigDecimal.ZERO) < 0) {
                throw new IllegalArgumentException("Đơn giá phải >= 0");
            }
            
            // Calculate detail total
            BigDecimal detailTotal = detailRequest.getUnitPrice()
                    .multiply(new BigDecimal(detailRequest.getQuantity()));
            totalAmount = totalAmount.add(detailTotal);
            
            // Create new invoice detail
            InvoiceDetail detail = new InvoiceDetail();
            detail.setInvoice(invoice);
            detail.setQuantity(detailRequest.getQuantity());
            detail.setUnitPrice(detailRequest.getUnitPrice());
            detail.setTotalAmount(detailTotal);
            
            // Set optional service package or additional service
            if (detailRequest.getServicePackageId() != null) {
                ServicePackage servicePackage = servicePackageRepository.findById(detailRequest.getServicePackageId())
                        .orElseThrow(() -> new IllegalArgumentException("Service package not found with ID: " + detailRequest.getServicePackageId()));
                detail.setServicePackage(servicePackage);
            }
            
            if (detailRequest.getAdditionalServiceId() != null) {
                AdditionalService additionalService = additionalServiceRepository.findById(detailRequest.getAdditionalServiceId())
                        .orElseThrow(() -> new IllegalArgumentException("Additional service not found with ID: " + detailRequest.getAdditionalServiceId()));
                detail.setAdditionalService(additionalService);
            }
            
            newDetails.add(detail);
        }
        
        // Step 7: Save new invoice details
        invoiceDetailRepository.saveAll(newDetails);
        logger.info("Created {} new invoice details for invoice ID: {}", newDetails.size(), invoiceId);
        
        // Step 8: Validate discount doesn't exceed total amount
        if (request.getDiscountAmount().compareTo(totalAmount) > 0) {
            throw new IllegalArgumentException("Chiết khấu không được vượt quá tổng tiền");
        }
        
        // Step 9: Calculate final amount
        BigDecimal finalAmount = totalAmount.subtract(request.getDiscountAmount());
        
        // Step 10: Update invoice information
        invoice.setMember(member);
        invoice.setTotalAmount(totalAmount);
        invoice.setDiscountAmount(request.getDiscountAmount());
        invoice.setFinalAmount(finalAmount);
        invoice.setPaymentMethod(request.getPaymentMethod());
        
        // Step 11: Save and return updated invoice
        Invoice updatedInvoice = invoiceRepository.save(invoice);
        logger.info("Invoice updated successfully with ID: {}, Total: {}, Discount: {}, Final: {}",
                   invoiceId, totalAmount, request.getDiscountAmount(), finalAmount);
        
        List<InvoiceDetail> updatedDetails = invoiceDetailRepository.findByInvoiceId(invoiceId);
        List<ResInvoiceDetailDTO> detailDTOs = updatedDetails.stream()
            .map(this::mapInvoiceDetailToDTO)
            .collect(Collectors.toList());
        
        return mapInvoiceToDTO(updatedInvoice, detailDTOs);
    }

    /**
     * Map Invoice entity to response DTO with details
     */
    private ResInvoiceDTO mapInvoiceToDTO(Invoice invoice, List<ResInvoiceDetailDTO> details) {
        if (invoice == null) {
            return null;
        }
        
        // Validate required relationships
        if (invoice.getMember() == null || invoice.getMember().getUser() == null) {
            throw new IllegalStateException("Invoice member or member user is null");
        }
        
        return ResInvoiceDTO.builder()
            .invoiceId(invoice.getId())
            .memberId(invoice.getMember().getId())
            .memberName(invoice.getMember().getUser().getFullname())
            .totalAmount(invoice.getTotalAmount())
            .discountAmount(invoice.getDiscountAmount())
            .finalAmount(invoice.getFinalAmount())
            .paymentMethod(invoice.getPaymentMethod())
            .paymentStatus(invoice.getPaymentStatus())
            .status(invoice.getStatus())
            .details(details)
            .createdAt(invoice.getCreatedAt())
            .updatedAt(invoice.getUpdatedAt())
            .createdBy(invoice.getCreatedBy())
            .build();
    }
}
