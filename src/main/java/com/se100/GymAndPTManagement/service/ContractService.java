/**
 * Generated by: GitHub Copilot (Claude Haiku 4.5)
 * Created by: KStuv
 * Created at: 2026-01-09 14:50:00
 * Purpose: Service for Contract entity business logic and transaction management
 */
package com.se100.GymAndPTManagement.service;

import com.se100.GymAndPTManagement.domain.requestDTO.ReqCreateContractDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResContractDTO;
import com.se100.GymAndPTManagement.domain.table.Contract;
import com.se100.GymAndPTManagement.domain.table.Invoice;
import com.se100.GymAndPTManagement.domain.table.Member;
import com.se100.GymAndPTManagement.domain.table.PersonalTrainer;
import com.se100.GymAndPTManagement.domain.table.ServicePackage;
import com.se100.GymAndPTManagement.repository.ContractRepository;
import com.se100.GymAndPTManagement.repository.InvoiceRepository;
import com.se100.GymAndPTManagement.repository.MemberRepository;
import com.se100.GymAndPTManagement.repository.PersonalTrainerRepository;
import com.se100.GymAndPTManagement.repository.ServicePackageRepository;
import com.se100.GymAndPTManagement.util.enums.ContractStatusEnum;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Service
public class ContractService {
    
    private final ContractRepository contractRepository;
    private final InvoiceRepository invoiceRepository;
    private final MemberRepository memberRepository;
    private final ServicePackageRepository servicePackageRepository;
    private final PersonalTrainerRepository personalTrainerRepository;
    
    public ContractService(ContractRepository contractRepository,
                          InvoiceRepository invoiceRepository,
                          MemberRepository memberRepository,
                          ServicePackageRepository servicePackageRepository,
                          PersonalTrainerRepository personalTrainerRepository) {
        this.contractRepository = contractRepository;
        this.invoiceRepository = invoiceRepository;
        this.memberRepository = memberRepository;
        this.servicePackageRepository = servicePackageRepository;
        this.personalTrainerRepository = personalTrainerRepository;
    }
    
    @Transactional
    public ResContractDTO createContractWithInvoice(ReqCreateContractDTO request) {
        // Validation: Check member exists
        Member member = memberRepository.findById(request.getMemberId())
            .orElseThrow(() -> new RuntimeException("Member not found with ID: " + request.getMemberId()));
        
        // Validation: Check service package exists
        ServicePackage servicePackage = servicePackageRepository.findById(request.getPackageId())
            .orElseThrow(() -> new RuntimeException("Service package not found with ID: " + request.getPackageId()));
        
        // Validation: Check PT exists if provided
        PersonalTrainer personalTrainer = null;
        if (request.getPtId() != null) {
            personalTrainer = personalTrainerRepository.findById(request.getPtId())
                .orElseThrow(() -> new RuntimeException("Personal trainer not found with ID: " + request.getPtId()));
        }
        
        // Validation: startDate < endDate
        if (request.getStartDate().isAfter(request.getEndDate())) {
            throw new RuntimeException("Start date must be before end date");
        }
        
        // Create Contract Entity
        Contract contract = Contract.builder()
            .member(member)
            .servicePackage(servicePackage)
            .mainPt(personalTrainer)
            .startDate(request.getStartDate())
            .endDate(request.getEndDate())
            .status(ContractStatusEnum.ACTIVE)
            .notes(request.getNotes())
            .signedAt(Instant.now())
            .build();
        
        // Save contract
        Contract savedContract = contractRepository.save(contract);
        
        // Create Invoice Entity automatically
        Invoice invoice = Invoice.builder()
            .member(member)
            .totalAmount(servicePackage.getPrice())
            .discountAmount(BigDecimal.ZERO)
            .finalAmount(servicePackage.getPrice())
            .paymentMethod(request.getPaymentMethod())
            .paymentStatus("PAID")
            .status("COMPLETED")
            .build();
        
        // Save invoice
        invoiceRepository.save(invoice);
        
        // Build and return response DTO
        return mapToResDTO(savedContract, member, servicePackage, personalTrainer);
    }
    
    public List<Contract> getContractsByMember(Long memberId) {
        return contractRepository.findByMemberId(memberId);
    }
    
    public List<Contract> getContractsByPt(Long ptId) {
        return contractRepository.findByMainPtId(ptId);
    }
    
    public List<Contract> getContractsByStatus(ContractStatusEnum status) {
        return contractRepository.findByStatus(status);
    }
    
    public Optional<Contract> getContractById(Long id) {
        return contractRepository.findById(id);
    }

    public List<Contract> getAllContracts() {
        return contractRepository.findAll();
    }
    
    // =========================================
    // Status Management Methods
    // =========================================
    
    /**
     * Auto-expire contracts that have passed their end date
     * Scheduled to run daily to check for expired contracts
     */
    @Transactional
    public void autoExpireContracts() {
        LocalDate today = LocalDate.now();
        
        // Find all ACTIVE contracts
        List<Contract> activeContracts = contractRepository.findByStatus(ContractStatusEnum.ACTIVE);
        
        for (Contract contract : activeContracts) {
            // Check if contract has expired (end_date < today)
            if (contract.getEndDate().isBefore(today)) {
                contract.setStatus(ContractStatusEnum.EXPIRED);
                contractRepository.save(contract);
            }
        }
    }
    
    /**
     * Check if a specific contract is expired
     */
    public boolean isContractExpired(Contract contract) {
        return contract.getEndDate().isBefore(LocalDate.now());
    }
    
    /**
     * Get the remaining days of a contract
     * Returns negative number if contract is expired
     */
    public long getRemainingDays(Contract contract) {
        return java.time.temporal.ChronoUnit.DAYS.between(LocalDate.now(), contract.getEndDate());
    }
    
    /**
     * Change contract status manually
     */
    @Transactional
    public void changeContractStatus(Long contractId, ContractStatusEnum newStatus) {
        Contract contract = contractRepository.findById(contractId)
            .orElseThrow(() -> new RuntimeException("Contract not found with ID: " + contractId));
        
        // Validate status transitions
        validateStatusTransition(contract.getStatus(), newStatus);
        
        contract.setStatus(newStatus);
        contractRepository.save(contract);
    }
    
    /**
     * Validate contract status transitions
     * - ACTIVE can transition to EXPIRED or CANCELLED
     * - EXPIRED can transition to CANCELLED
     * - CANCELLED cannot transition to any other status
     */
    private void validateStatusTransition(ContractStatusEnum currentStatus, ContractStatusEnum newStatus) {
        if (currentStatus == newStatus) {
            throw new RuntimeException("Contract is already in status: " + currentStatus);
        }
        
        switch (currentStatus) {
            case ACTIVE:
                if (newStatus != ContractStatusEnum.EXPIRED && newStatus != ContractStatusEnum.CANCELLED) {
                    throw new RuntimeException("ACTIVE contract can only transition to EXPIRED or CANCELLED");
                }
                break;
            case EXPIRED:
                if (newStatus != ContractStatusEnum.CANCELLED) {
                    throw new RuntimeException("EXPIRED contract can only transition to CANCELLED");
                }
                break;
            case CANCELLED:
                throw new RuntimeException("CANCELLED contract cannot transition to any other status");
        }
    }
        
    // Mapper
    // =========================================
    private ResContractDTO mapToResDTO(Contract contract, Member member,
                                       ServicePackage servicePackage,
                                       PersonalTrainer personalTrainer) {
        return ResContractDTO.builder()
                .id(contract.getId())
                .memberId(member.getId())
                .memberName(member.getUser().getFullname())
                .packageId(servicePackage.getId())
                .packageName(servicePackage.getPackageName())
                .packagePrice(servicePackage.getPrice())
                .ptId(personalTrainer != null ? personalTrainer.getId() : null)
                .ptName(personalTrainer != null ? personalTrainer.getUser().getFullname() : null)
                .startDate(contract.getStartDate())
                .endDate(contract.getEndDate())
                .status(contract.getStatus().name())
                .notes(contract.getNotes())
                .signedAt(contract.getSignedAt())
                .createdAt(contract.getCreatedAt())
                .build();
    }
}
