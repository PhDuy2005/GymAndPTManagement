/**
 * Generated by: GitHub Copilot (Claude Haiku 4.5)
 * Created by: KStuv
 * Created at: 2026-01-09 14:50:00
 * Purpose: Service for Contract entity business logic and transaction management
 */
package com.se100.GymAndPTManagement.service;

import com.se100.GymAndPTManagement.domain.requestDTO.ReqCreateContractDTO;
import com.se100.GymAndPTManagement.domain.requestDTO.ReqUpdateContractDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResContractDTO;
import com.se100.GymAndPTManagement.domain.table.Contract;
import com.se100.GymAndPTManagement.domain.table.Invoice;
import com.se100.GymAndPTManagement.domain.table.InvoiceDetail;
import com.se100.GymAndPTManagement.domain.table.Member;
import com.se100.GymAndPTManagement.domain.table.PersonalTrainer;
import com.se100.GymAndPTManagement.domain.table.ServicePackage;
import com.se100.GymAndPTManagement.repository.ContractRepository;
import com.se100.GymAndPTManagement.repository.InvoiceRepository;
import com.se100.GymAndPTManagement.repository.InvoiceDetailRepository;
import com.se100.GymAndPTManagement.util.enums.PaymentStatusEnum;
import com.se100.GymAndPTManagement.repository.MemberRepository;
import com.se100.GymAndPTManagement.repository.PersonalTrainerRepository;
import com.se100.GymAndPTManagement.repository.ServicePackageRepository;
import com.se100.GymAndPTManagement.util.enums.ContractStatusEnum;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Service
public class ContractService {
    
    private final ContractRepository contractRepository;
    private final InvoiceRepository invoiceRepository;
    private final InvoiceDetailRepository invoiceDetailRepository;
    private final MemberRepository memberRepository;
    private final ServicePackageRepository servicePackageRepository;
    private final PersonalTrainerRepository personalTrainerRepository;
    
    public ContractService(ContractRepository contractRepository,
                          InvoiceRepository invoiceRepository,
                          InvoiceDetailRepository invoiceDetailRepository,
                          MemberRepository memberRepository,
                          ServicePackageRepository servicePackageRepository,
                          PersonalTrainerRepository personalTrainerRepository) {
        this.contractRepository = contractRepository;
        this.invoiceRepository = invoiceRepository;
        this.invoiceDetailRepository = invoiceDetailRepository;
        this.memberRepository = memberRepository;
        this.servicePackageRepository = servicePackageRepository;
        this.personalTrainerRepository = personalTrainerRepository;
    }
    
    @Transactional
    public ResContractDTO createContractWithInvoice(ReqCreateContractDTO request) {
        // Validation: Check member exists
        Member member = memberRepository.findById(request.getMemberId())
            .orElseThrow(() -> new IllegalArgumentException("Member not found with ID: " + request.getMemberId()));
        
        // Validation: Check service package exists
        ServicePackage servicePackage = servicePackageRepository.findById(request.getPackageId())
            .orElseThrow(() -> new IllegalArgumentException("Service package not found with ID: " + request.getPackageId()));
        
        // Validation: Check PT exists if provided
        PersonalTrainer personalTrainer = null;
        if (request.getPtId() != null) {
            personalTrainer = personalTrainerRepository.findById(request.getPtId())
                .orElseThrow(() -> new IllegalArgumentException("Personal trainer not found with ID: " + request.getPtId()));
        }
        
        // Validation: startDate must be present or future
        if (request.getStartDate().isBefore(LocalDate.now())) {
            throw new IllegalArgumentException("Start date must be present or future date");
        }
        
        // Calculate endDate based on duration_in_days from service package
        if (servicePackage.getDurationInDays() == null || servicePackage.getDurationInDays() <= 0) {
            throw new IllegalArgumentException("Service package must have valid duration_in_days (> 0)");
        }
        
        LocalDate calculatedEndDate = request.getStartDate().plusDays(servicePackage.getDurationInDays());
        
        // Validation: If endDate is provided, verify it matches calculated endDate
        if (request.getEndDate() != null) {
            if (!request.getEndDate().equals(calculatedEndDate)) {
                throw new IllegalArgumentException(
                    String.format("End date must be calculated as start_date + %d days. " +
                                "Expected: %s, Provided: %s",
                                servicePackage.getDurationInDays(),
                                calculatedEndDate,
                                request.getEndDate())
                );
            }
        }
        
        // Create Contract Entity with automatically calculated endDate
        Contract contract = Contract.builder()
            .member(member)
            .servicePackage(servicePackage)
            .mainPt(personalTrainer)
            .startDate(request.getStartDate())
            .endDate(calculatedEndDate)
            .totalSessions(servicePackage.getNumberOfSessions())
            .remainingSessions(servicePackage.getNumberOfSessions())
            .status(ContractStatusEnum.ACTIVE)
            .notes(request.getNotes())
            .signedAt(Instant.now())
            .build();
        
        // Save contract
        Contract savedContract = contractRepository.save(contract);
        
        // Calculate invoice amounts
        // Step 1: Get discount from request (default 0 if null)
        BigDecimal discountAmount = request.getDiscountAmount() != null 
            ? request.getDiscountAmount() 
            : BigDecimal.ZERO;
        
        // Step 2: Get total amount from service package price
        BigDecimal totalAmount = servicePackage.getPrice();
        
        // Step 3: Validate discount is not greater than total
        if (discountAmount.compareTo(totalAmount) > 0) {
            throw new IllegalArgumentException("Discount amount cannot exceed total amount");
        }
        
        // Step 4: Calculate final amount
        BigDecimal finalAmount = totalAmount.subtract(discountAmount);
        
        // Step 5: Create Invoice Entity automatically
        Invoice invoice = Invoice.builder()
            .member(member)
            .totalAmount(totalAmount)
            .discountAmount(discountAmount)
            .finalAmount(finalAmount)
            .paymentMethod(request.getPaymentMethod())
            .paymentStatus(PaymentStatusEnum.UNPAID)  // Default UNPAID
            .status("ISSUED")  // Invoice issued
            .build();
        
        // Step 6: Save invoice
        Invoice savedInvoice = invoiceRepository.save(invoice);
        
        // Step 7: Create InvoiceDetail for service package
        InvoiceDetail invoiceDetail = InvoiceDetail.builder()
            .invoice(savedInvoice)
            .servicePackage(servicePackage)
            .additionalService(null)  // No additional service for now
            .quantity(1)  // Quantity is always 1 for service package
            .unitPrice(servicePackage.getPrice())  // Unit price = service package price
            .totalAmount(servicePackage.getPrice())  // Total = quantity * unitPrice = 1 * price
            .build();
        
        // Step 8: Save invoice detail
        invoiceDetailRepository.save(invoiceDetail);
        
        // Build and return response DTO
        return mapToResDTO(savedContract);
    }
    
    public List<Contract> getContractsByMember(Long memberId) {
        return contractRepository.findByMemberId(memberId);
    }
    
    public List<Contract> getContractsByPt(Long ptId) {
        return contractRepository.findByMainPtId(ptId);
    }
    
    public List<Contract> getContractsByStatus(ContractStatusEnum status) {
        return contractRepository.findByStatus(status);
    }
    
    public Optional<Contract> getContractById(Long id) {
        return contractRepository.findById(id);
    }

    public List<Contract> getAllContracts() {
        return contractRepository.findAll();
    }
    
    // =========================================
    // Status Management Methods
    // =========================================
    
    /**
     * Auto-expire contracts that have passed their end date OR remaining sessions = 0
     * Scheduled to run daily to check for expired contracts
     */
    @Transactional
    public void autoExpireContracts() {
        LocalDate today = LocalDate.now();
        
        // Find all ACTIVE contracts
        List<Contract> activeContracts = contractRepository.findByStatus(ContractStatusEnum.ACTIVE);
        
        for (Contract contract : activeContracts) {
            boolean shouldExpire = false;
            String reason = "";
            
            // Check if contract has expired (end_date < today)
            if (contract.getEndDate().isBefore(today)) {
                shouldExpire = true;
                reason = "end_date expired";
            }
            
            // Check if remaining sessions = 0
            if (contract.getRemainingSessions() != null && contract.getRemainingSessions() <= 0) {
                shouldExpire = true;
                reason = reason.isEmpty() ? "remaining_sessions exhausted" : reason + " AND remaining_sessions exhausted";
            }
            
            if (shouldExpire) {
                contract.setStatus(ContractStatusEnum.EXPIRED);
                contractRepository.save(contract);
            }
        }
    }
    
    /**
     * Check if a specific contract is expired by end_date OR remaining_sessions = 0
     */
    public boolean isContractExpired(Contract contract) {
        // Expired if end_date passed
        if (contract.getEndDate().isBefore(LocalDate.now())) {
            return true;
        }
        
        // Expired if remaining sessions exhausted (= 0 or negative)
        if (contract.getRemainingSessions() != null && contract.getRemainingSessions() <= 0) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Check if remaining sessions are about to be exhausted
     * Returns true if remaining sessions <= 0
     */
    public boolean hasExhaustedSessions(Contract contract) {
        return contract.getRemainingSessions() != null && contract.getRemainingSessions() <= 0;
    }
    
    /**
     * Get the remaining days of a contract
     * Returns negative number if contract is expired
     */
    public long getRemainingDays(Contract contract) {
        return java.time.temporal.ChronoUnit.DAYS.between(LocalDate.now(), contract.getEndDate());
    }
    
    /**
     * Change contract status manually
     */
    @Transactional
    public void changeContractStatus(Long contractId, ContractStatusEnum newStatus) {
        Contract contract = contractRepository.findById(contractId)
            .orElseThrow(() -> new RuntimeException("Contract not found with ID: " + contractId));
        
        // Validate status transitions
        validateStatusTransition(contract.getStatus(), newStatus);
        
        contract.setStatus(newStatus);
        contractRepository.save(contract);
    }
    
    /**
     * Validate contract status transitions
     * - ACTIVE can transition to EXPIRED or CANCELLED
     * - EXPIRED can transition to CANCELLED
     * - CANCELLED cannot transition to any other status
     */
    private void validateStatusTransition(ContractStatusEnum currentStatus, ContractStatusEnum newStatus) {
        if (currentStatus == newStatus) {
            throw new RuntimeException("Contract is already in status: " + currentStatus);
        }
        
        switch (currentStatus) {
            case ACTIVE:
                if (newStatus != ContractStatusEnum.EXPIRED && newStatus != ContractStatusEnum.CANCELLED) {
                    throw new RuntimeException("ACTIVE contract can only transition to EXPIRED or CANCELLED");
                }
                break;
            case EXPIRED:
                if (newStatus != ContractStatusEnum.CANCELLED) {
                    throw new RuntimeException("EXPIRED contract can only transition to CANCELLED");
                }
                break;
            case CANCELLED:
                throw new RuntimeException("CANCELLED contract cannot transition to any other status");
        }
    }
        
    // Mapper
    // =========================================
    /**
     * Delete contract by ID
     * 
     * @param contractId - Contract ID to delete
     * @throws IllegalArgumentException if contract not found
     */
    @Transactional
    public void deleteContract(Long contractId) {
        Contract contract = contractRepository.findById(contractId)
            .orElseThrow(() -> new IllegalArgumentException("Contract not found with ID: " + contractId));
        
        contractRepository.delete(contract);
    }

    /**
     * Update contract information
     * 
     * Validation rules:
     * 1. Contract must exist
     * 2. Service package must exist
     * 3. PT must exist
     * 4. Start date must be present or future
     * 5. End date must be after start date
     * 6. Total sessions must be positive
     * 7. If reducing total sessions, remaining sessions must not exceed new total
     * 
     * @param contractId Contract ID to update
     * @param request Update request with new contract information
     * @return Updated contract response DTO
     * @throws IllegalArgumentException if validation fails
     */
    @Transactional
    public ResContractDTO updateContract(Long contractId, ReqUpdateContractDTO request) {
        // Step 1: Fetch and validate contract exists
        Contract contract = contractRepository.findById(contractId)
                .orElseThrow(() -> new IllegalArgumentException("Hợp đồng không tồn tại"));
        
        // Step 2: Validate new service package exists
        ServicePackage servicePackage = servicePackageRepository.findById(request.getPackageId())
                .orElseThrow(() -> new IllegalArgumentException("Gói dịch vụ không tồn tại"));
        
        // Step 3: Validate PT exists
        PersonalTrainer personalTrainer = personalTrainerRepository.findById(request.getPtId())
                .orElseThrow(() -> new IllegalArgumentException("PT không tồn tại"));
        
        // Step 4: Validate dates
        if (request.getStartDate().isAfter(request.getEndDate())) {
            throw new IllegalArgumentException("Ngày bắt đầu phải trước ngày kết thúc");
        }
        
        // Step 5: Validate total sessions
        if (request.getTotalSessions() <= 0) {
            throw new IllegalArgumentException("Tổng số buổi phải lớn hơn 0");
        }
        
        // Step 6: If reducing total sessions, validate remaining sessions doesn't exceed new total
        if (request.getTotalSessions() < contract.getTotalSessions()) {
            Integer remainingSessions = contract.getRemainingSessions() != null ? contract.getRemainingSessions() : contract.getTotalSessions();
            if (remainingSessions > request.getTotalSessions()) {
                throw new IllegalArgumentException("Không thể giảm tổng buổi vì số buổi còn lại vượt quá số buổi mới");
            }
        }
        
        // Step 7: Update contract information
        contract.setServicePackage(servicePackage);
        contract.setMainPt(personalTrainer);
        contract.setStartDate(request.getStartDate());
        contract.setEndDate(request.getEndDate());
        contract.setTotalSessions(request.getTotalSessions());
        contract.setNotes(request.getNotes());
        
        // Step 8: Save and return updated contract
        Contract updatedContract = contractRepository.save(contract);
        
        return mapToResDTO(updatedContract);
    }

    /**
     * Map Contract entity to ResContractDTO
     * Extracts all related data from Contract object and its relationships
     * Includes null safety checks for all relationships
     */
    private ResContractDTO mapToResDTO(Contract contract) {
        // Validate required relationships exist
        if (contract.getMember() == null || contract.getMember().getUser() == null) {
            throw new IllegalStateException("Contract member or member user is null");
        }
        if (contract.getServicePackage() == null) {
            throw new IllegalStateException("Contract service package is null");
        }
        
        Member member = contract.getMember();
        ServicePackage servicePackage = contract.getServicePackage();
        PersonalTrainer personalTrainer = contract.getMainPt();
        
        // Safely get PT name - handle null PT and null PT user
        String ptName = null;
        Long ptId = null;
        if (personalTrainer != null && personalTrainer.getUser() != null) {
            ptId = personalTrainer.getId();
            ptName = personalTrainer.getUser().getFullname();
        }
        
        return ResContractDTO.builder()
                .id(contract.getId())
                .memberId(member.getId())
                .memberName(member.getUser().getFullname())
                .packageId(servicePackage.getId())
                .packageName(servicePackage.getPackageName())
                .packagePrice(servicePackage.getPrice())
                .ptId(ptId)
                .ptName(ptName)
                .startDate(contract.getStartDate())
                .endDate(contract.getEndDate())
                .totalSessions(contract.getTotalSessions())
                .remainingSessions(contract.getRemainingSessions())
                .status(contract.getStatus().name())
                .notes(contract.getNotes())
                .signedAt(contract.getSignedAt())
                .createdAt(contract.getCreatedAt())
                .build();
    }
}
