package com.se100.GymAndPTManagement.service;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;

import com.se100.GymAndPTManagement.domain.requestDTO.ReqCreateSlotDTO;
import com.se100.GymAndPTManagement.domain.requestDTO.ReqUpdateSlotDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResAvailableSlotByDateRangeDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResSlotDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResultPaginationDTO;
import com.se100.GymAndPTManagement.domain.table.AvailableSlot;
import com.se100.GymAndPTManagement.domain.table.PersonalTrainer;
import com.se100.GymAndPTManagement.domain.table.Slot;
import com.se100.GymAndPTManagement.repository.AvailableSlotRepository;
import com.se100.GymAndPTManagement.repository.PersonalTrainerRepository;
import com.se100.GymAndPTManagement.repository.SlotRepository;
import com.se100.GymAndPTManagement.util.enums.DayOfWeekEnum;
import com.se100.GymAndPTManagement.util.error.IdInvalidException;

import lombok.RequiredArgsConstructor;

/**
 * Generated by: GitHub Copilot (Claude Sonnet 4.5)
 * Created by: PhDuy2005
 * Created at: 2026-01-13 23:53:21
 * Purpose: Service for Slot entity
 */
@Service
@RequiredArgsConstructor
public class SlotService {

    private final SlotRepository slotRepository;
    private final AvailableSlotRepository availableSlotRepository;
    private final PersonalTrainerRepository personalTrainerRepository;

    public ResSlotDTO createSlot(ReqCreateSlotDTO request) {
        // Validate time logic
        if (request.getStartTime().isAfter(request.getEndTime()) ||
                request.getStartTime().equals(request.getEndTime())) {
            throw new IllegalArgumentException("Start time must be before end time");
        }

        Slot slot = Slot.builder()
                .slotName(request.getSlotName())
                .startTime(request.getStartTime())
                .endTime(request.getEndTime())
                .isActive(true)
                .build();

        Slot savedSlot = slotRepository.save(slot);
        return ResSlotDTO.fromEntity(savedSlot);
    }

    public List<ResSlotDTO> getAllSlots() {
        return slotRepository.findAll().stream()
                .map(ResSlotDTO::fromEntity)
                .collect(Collectors.toList());
    }

    public ResSlotDTO getSlotById(Long id) {
        Slot slot = slotRepository.findById(id)
                .orElseThrow(() -> new IdInvalidException("Slot not found with id: " + id));
        return ResSlotDTO.fromEntity(slot);
    }

    public ResSlotDTO updateSlot(Long id, ReqUpdateSlotDTO request) {
        Slot slot = slotRepository.findById(id)
                .orElseThrow(() -> new IdInvalidException("Slot not found with id: " + id));

        // Validate time logic
        if (request.getStartTime().isAfter(request.getEndTime()) ||
                request.getStartTime().equals(request.getEndTime())) {
            throw new IllegalArgumentException("Start time must be before end time");
        }

        slot.setSlotName(request.getSlotName());
        slot.setStartTime(request.getStartTime());
        slot.setEndTime(request.getEndTime());

        Slot updatedSlot = slotRepository.save(slot);
        return ResSlotDTO.fromEntity(updatedSlot);
    }

    public void deleteSlot(Long id) {
        Slot slot = slotRepository.findById(id)
                .orElseThrow(() -> new IdInvalidException("Slot not found with id: " + id));
        slot.setIsActive(false);
        slotRepository.save(slot);
    }

    public List<ResSlotDTO> getAllActiveSlots() {
        return slotRepository.findByIsActive(true).stream()
                .map(ResSlotDTO::fromEntity)
                .collect(Collectors.toList());
    }

    public ResSlotDTO activateSlot(Long id) {
        Slot slot = slotRepository.findById(id)
                .orElseThrow(() -> new IdInvalidException("Slot not found with id: " + id));
        slot.setIsActive(true);
        Slot activatedSlot = slotRepository.save(slot);
        return ResSlotDTO.fromEntity(activatedSlot);
    }

    public ResultPaginationDTO handleFetchSlots(Specification<Slot> specification, Pageable pageable) {
        Page<Slot> slotPage = slotRepository.findAll(specification, pageable);

        ResultPaginationDTO result = new ResultPaginationDTO();
        ResultPaginationDTO.Meta meta = new ResultPaginationDTO.Meta();

        meta.setPage(pageable.getPageNumber() + 1);
        meta.setPageSize(pageable.getPageSize());
        meta.setTotalPages(slotPage.getTotalPages());
        meta.setTotalItems(slotPage.getTotalElements());

        result.setMeta(meta);

        List<ResSlotDTO> slotDTOs = slotPage.getContent().stream()
                .map(ResSlotDTO::fromEntity)
                .collect(Collectors.toList());

        result.setResult(slotDTOs);

        return result;
    }

    /**
     * Fetch all available slots for a PT within a date range
     * 
     * @param ptId      ID of the Personal Trainer
     * @param startDate Start date of the range
     * @param range     Number of days to search (default: 7)
     * @return List of available slots grouped by date
     */
    public List<ResAvailableSlotByDateRangeDTO> getAvailableSlotsByPTAndDateRange(
            Long ptId, LocalDate startDate, Integer range) {
        // Validate PT exists
        PersonalTrainer pt = personalTrainerRepository.findById(ptId)
                .orElseThrow(() -> new IdInvalidException("Personal trainer not found with id: " + ptId));

        // Get all available slots for this PT where isAvailable = true
        List<AvailableSlot> availableSlots = availableSlotRepository
                .findByPersonalTrainerIdAndIsAvailable(ptId, true);

        // Build response for each date in the range
        List<ResAvailableSlotByDateRangeDTO> result = new ArrayList<>();

        for (int i = 0; i < range; i++) {
            LocalDate currentDate = startDate.plusDays(i);
            DayOfWeek dayOfWeek = currentDate.getDayOfWeek();
            DayOfWeekEnum dayOfWeekEnum = DayOfWeekEnum.valueOf(dayOfWeek.name());

            // Filter available slots for this day of week
            availableSlots.stream()
                    .filter(as -> as.getDayOfWeek() == dayOfWeekEnum)
                    .forEach(as -> {
                        ResAvailableSlotByDateRangeDTO dto = ResAvailableSlotByDateRangeDTO.builder()
                                .dayOfWeek(dayOfWeekEnum)
                                .date(currentDate)
                                .pt(ResAvailableSlotByDateRangeDTO.PT.builder()
                                        .ptId(pt.getId())
                                        .name(pt.getUser().getFullname())
                                        .build())
                                .slot(ResAvailableSlotByDateRangeDTO.Slot.builder()
                                        .slotId(as.getSlot().getId())
                                        .name(as.getSlot().getSlotName())
                                        .startTime(as.getSlot().getStartTime())
                                        .endTime(as.getSlot().getEndTime())
                                        .build())
                                .build();
                        result.add(dto);
                    });
        }

        return result;
    }
}
