/**
 * Generated by: GitHub Copilot (Claude Haiku 4.5)
 * Created by: KStuv
 * Created at: 2026-01-14 10:10:00
 * Purpose: Service for Booking management with dynamic filtering and validation
 */
package com.se100.GymAndPTManagement.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.se100.GymAndPTManagement.domain.table.*;
import com.se100.GymAndPTManagement.domain.requestDTO.ReqCreateBookingDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResBookingDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResAvailableSlotDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResAvailablePTDTO;
import com.se100.GymAndPTManagement.repository.*;
import com.se100.GymAndPTManagement.util.enums.ContractStatusEnum;

import lombok.RequiredArgsConstructor;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class BookingService {

    private final BookingRepository bookingRepository;
    private final ContractRepository contractRepository;
    private final MemberRepository memberRepository;
    private final PersonalTrainerRepository personalTrainerRepository;
    private final SlotRepository slotRepository;
    private final AvailableSlotRepository availableSlotRepository;
    private final ContractService contractService;

    /**
     * Get available slots for a PT on a specific date (Flow 1)
     * 
     * @param ptId Personal Trainer ID
     * @param date Booking date
     * @return List of available slots
     */
    @Transactional(readOnly = true)
    public List<ResAvailableSlotDTO> getAvailableSlotsForPT(Long ptId, LocalDate date) {
        // Determine day of week (e.g., "MONDAY")
        String dayOfWeek = date.getDayOfWeek().name();

        // Query available slots from repository
        List<Slot> availableSlots = bookingRepository.getAvailableSlotsForPT(ptId, dayOfWeek, date);

        // Map to response DTOs
        return availableSlots.stream()
                .map(slot -> ResAvailableSlotDTO.builder()
                        .slotId(slot.getId())
                        .startTime(slot.getStartTime())
                        .endTime(slot.getEndTime())
                        .build())
                .collect(Collectors.toList());
    }

    /**
     * Get available PTs for a specific slot on a specific date (Flow 2)
     * 
     * @param slotId Slot ID
     * @param date Booking date
     * @return List of available PTs
     */
    @Transactional(readOnly = true)
    public List<ResAvailablePTDTO> getAvailablePTsForSlot(Long slotId, LocalDate date) {
        // Determine day of week
        String dayOfWeek = date.getDayOfWeek().name();

        // Query available PTs from repository
        List<PersonalTrainer> availablePTs = bookingRepository.getAvailablePTsForSlot(slotId, dayOfWeek, date);

        // Map to response DTOs
        return availablePTs.stream()
                .map(pt -> ResAvailablePTDTO.builder()
                        .ptId(pt.getId())
                        .ptName(pt.getUser().getFullname())
                        .specialization(pt.getSpecialization())
                        .experienceYears(pt.getExperienceYears())
                        .build())
                .collect(Collectors.toList());
    }

    /**
     * Create a new booking with validation
     * 
     * Business Logic:
     * 1. Validate member has active contract that covers the booking date
     * 2. Check if contract is expired (by end_date or remaining_sessions = 0)
     * 3. Validate PT exists
     * 4. Validate slot exists
     * 5. Check for duplicate booking (same PT, slot, date)
     * 6. Save the booking
     * 7. Decrease remaining_sessions by 1 from contract
     * 
     * @param dto Create booking request DTO
     * @return Created booking response DTO
     * @throws IllegalArgumentException if validation fails
     */
    @Transactional
    public ResBookingDTO createBooking(ReqCreateBookingDTO dto) {
        // Step 1: Validate member exists
        Member member = memberRepository.findById(dto.getMemberId())
                .orElseThrow(() -> new IllegalArgumentException("Member không tồn tại"));

        // Step 2: Find active contract for member that covers booking date
        Contract activeContract = contractRepository.findByMemberIdAndStatusAndDateRange(
                dto.getMemberId(),
                ContractStatusEnum.ACTIVE,
                dto.getBookingDate())
                .orElseThrow(() -> new IllegalArgumentException(
                        "Thành viên không có hợp đồng hoạt động hợp lệ cho ngày đặt lịch này"));

        // Step 2.1: Check if contract has expired (by end_date or remaining_sessions = 0)
        if (activeContract.getEndDate().isBefore(dto.getBookingDate())) {
            // Contract has expired by end_date
            // If status is still ACTIVE, update it to EXPIRED
            if (activeContract.getStatus() != ContractStatusEnum.EXPIRED) {
                contractService.changeContractStatus(activeContract.getId(), ContractStatusEnum.EXPIRED);
            }
            throw new IllegalArgumentException("Hợp đồng đã hết hạn (end_date đã qua)");
        }

        // Step 2.2: Check if contract has exhausted all remaining sessions (defensive check)
        // Note: This should rarely happen since Step 7.1 auto-expires contract when remaining_sessions = 0
        // But keeping as safety net for data consistency
        if (activeContract.getRemainingSessions() != null && activeContract.getRemainingSessions() <= 0) {
            throw new IllegalArgumentException("Hợp đồng đã hết buổi tập (remaining_sessions = 0)");
        }

        // Step 3: Validate PT exists
        PersonalTrainer pt = personalTrainerRepository.findById(dto.getPtId())
                .orElseThrow(() -> new IllegalArgumentException("PT không tồn tại"));

        // Step 4: Validate slot exists
        Slot slot = slotRepository.findById(dto.getSlotId())
                .orElseThrow(() -> new IllegalArgumentException("Khung giờ không tồn tại"));

        // Step 5: Check for duplicate booking
        boolean isDuplicate = bookingRepository.findByRealPtIdAndSlotIdAndBookingDate(
                dto.getPtId(),
                dto.getSlotId(),
                dto.getBookingDate())
                .isPresent();

        if (isDuplicate) {
            throw new IllegalArgumentException("Khung giờ này đã được đặt cho PT này rồi");
        }

        // Step 6: Create and save booking
        Booking booking = Booking.builder()
                .contract(activeContract)
                .member(member)
                .realPt(pt)
                .slot(slot)
                .bookingDate(dto.getBookingDate())
                .build();

        Booking savedBooking = bookingRepository.save(booking);

        // Step 7: Decrease remaining sessions from active contract
        if (activeContract.getRemainingSessions() != null && activeContract.getRemainingSessions() > 0) {
            activeContract.setRemainingSessions(activeContract.getRemainingSessions() - 1);
            
            // Step 7.1: If remaining sessions becomes 0, auto update status to EXPIRED
            if (activeContract.getRemainingSessions() <= 0 && activeContract.getStatus() != ContractStatusEnum.EXPIRED) {
                activeContract.setStatus(ContractStatusEnum.EXPIRED);
            }
            
            contractRepository.save(activeContract);
        }

        // Step 8: Return response DTO
        return mapToResponseDTO(savedBooking);
    }

    /**
     * Get all bookings for a member
     */
    @Transactional(readOnly = true)
    public List<ResBookingDTO> getAllBookings() {
        return bookingRepository.findAll()
                .stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Get all bookings for a member
     */
    @Transactional(readOnly = true)
    public List<ResBookingDTO> getBookingsByMember(Long memberId) {
        return bookingRepository.findByMemberId(memberId)
                .stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Get all bookings for a PT
     */
    @Transactional(readOnly = true)
    public List<ResBookingDTO> getBookingsByPT(Long ptId) {
        return bookingRepository.findByRealPtId(ptId)
                .stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Get booking by ID
     */
    @Transactional(readOnly = true)
    public ResBookingDTO getBookingById(Long bookingId) {
        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> new IllegalArgumentException("Booking không tồn tại"));
        return mapToResponseDTO(booking);
    }

    /**
     * Update personal trainer for a booking
     * 
     * Business Logic:
     * 1. Find booking by ID
     * 2. Validate PT exists
     * 3. Update booking realPt with new PT
     * 4. Save the booking
     * 
     * @param bookingId Booking ID
     * @param newPtId New Personal Trainer ID
     * @return Updated booking DTO
     * @throws IllegalArgumentException if booking or PT not found
     */
    @Transactional
    public ResBookingDTO updateBookingPT(Long bookingId, Long newPtId) {
        // Step 1: Find booking
        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> new IllegalArgumentException("Booking không tồn tại"));
        
        // Step 2: Validate PT exists
        PersonalTrainer newPt = personalTrainerRepository.findById(newPtId)
                .orElseThrow(() -> new IllegalArgumentException("Personal trainer không tồn tại"));
        
        // Step 3: Update PT
        booking.setRealPt(newPt);
        
        // Step 4: Save booking
        Booking updatedBooking = bookingRepository.save(booking);
        
        return mapToResponseDTO(updatedBooking);
    }

    /**
     * Delete a booking and restore remaining sessions to contract
     * 
     * Business Logic:
     * 1. Find booking by ID
     * 2. Get the associated contract
     * 3. Restore remaining_sessions by incrementing by 1
     * 4. Delete the booking
     * 
     * @param bookingId Booking ID to delete
     * @throws IllegalArgumentException if booking not found
     */
    @Transactional
    public void deleteBooking(Long bookingId) {
        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> new IllegalArgumentException("Booking không tồn tại"));

        // Get the contract and restore remaining sessions
        Contract contract = booking.getContract();
        if (contract.getRemainingSessions() != null && contract.getRemainingSessions() < contract.getTotalSessions()) {
            contract.setRemainingSessions(contract.getRemainingSessions() + 1);
            contractRepository.save(contract);
        }

        // Delete the booking
        bookingRepository.delete(booking);
    }

    /**
     * Map Booking entity to response DTO
     */
    private ResBookingDTO mapToResponseDTO(Booking booking) {
        return ResBookingDTO.builder()
                .id(booking.getId())
                .contractId(booking.getContract().getId())
                .memberId(booking.getMember().getId())
                .memberName(booking.getMember().getUser().getFullname())
                .ptId(booking.getRealPt() != null ? booking.getRealPt().getId() : null)
                .ptName(booking.getRealPt() != null ? booking.getRealPt().getUser().getFullname() : null)
                .slotId(booking.getSlot().getId())
                .slotStartTime(booking.getSlot().getStartTime())
                .slotEndTime(booking.getSlot().getEndTime())
                .bookingDate(booking.getBookingDate())
                .createdBy(booking.getCreatedBy())
                .build();
    }
}
