/**
 * Generated by: GitHub Copilot (Claude Haiku 4.5)
 * Created by: KStuv
 * Created at: 2026-01-14 10:10:00
 * Purpose: Service for Booking management with dynamic filtering and validation
 */
package com.se100.GymAndPTManagement.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.se100.GymAndPTManagement.domain.table.*;
import com.se100.GymAndPTManagement.domain.requestDTO.ReqCreateBookingDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResBookingDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResAvailableSlotDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResAvailablePTDTO;
import com.se100.GymAndPTManagement.repository.*;
import com.se100.GymAndPTManagement.util.enums.ContractStatusEnum;

import lombok.RequiredArgsConstructor;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class BookingService {

    private final BookingRepository bookingRepository;
    private final ContractRepository contractRepository;
    private final MemberRepository memberRepository;
    private final PersonalTrainerRepository personalTrainerRepository;
    private final SlotRepository slotRepository;
    private final AvailableSlotRepository availableSlotRepository;

    /**
     * Get available slots for a PT on a specific date (Flow 1)
     * 
     * @param ptId Personal Trainer ID
     * @param date Booking date
     * @return List of available slots
     */
    @Transactional(readOnly = true)
    public List<ResAvailableSlotDTO> getAvailableSlotsForPT(Long ptId, LocalDate date) {
        // Determine day of week (e.g., "MONDAY")
        String dayOfWeek = date.getDayOfWeek().name();

        // Query available slots from repository
        List<Slot> availableSlots = bookingRepository.getAvailableSlotsForPT(ptId, dayOfWeek, date);

        // Map to response DTOs
        return availableSlots.stream()
                .map(slot -> ResAvailableSlotDTO.builder()
                        .slotId(slot.getId())
                        .startTime(slot.getStartTime())
                        .endTime(slot.getEndTime())
                        .build())
                .collect(Collectors.toList());
    }

    /**
     * Get available PTs for a specific slot on a specific date (Flow 2)
     * 
     * @param slotId Slot ID
     * @param date Booking date
     * @return List of available PTs
     */
    @Transactional(readOnly = true)
    public List<ResAvailablePTDTO> getAvailablePTsForSlot(Long slotId, LocalDate date) {
        // Determine day of week
        String dayOfWeek = date.getDayOfWeek().name();

        // Query available PTs from repository
        List<PersonalTrainer> availablePTs = bookingRepository.getAvailablePTsForSlot(slotId, dayOfWeek, date);

        // Map to response DTOs
        return availablePTs.stream()
                .map(pt -> ResAvailablePTDTO.builder()
                        .ptId(pt.getId())
                        .ptName(pt.getUser().getFullname())
                        .specialization(pt.getSpecialization())
                        .experienceYears(pt.getExperienceYears())
                        .build())
                .collect(Collectors.toList());
    }

    /**
     * Create a new booking with validation
     * 
     * Business Logic:
     * 1. Validate member has active contract that covers the booking date
     * 2. Check for duplicate booking (same PT, slot, date)
     * 3. Save the booking
     * 
     * @param dto Create booking request DTO
     * @return Created booking response DTO
     * @throws IllegalArgumentException if validation fails
     */
    @Transactional
    public ResBookingDTO createBooking(ReqCreateBookingDTO dto) {
        // Step 1: Validate member exists
        Member member = memberRepository.findById(dto.getMemberId())
                .orElseThrow(() -> new IllegalArgumentException("Member không tồn tại"));

        // Step 2: Find active contract for member that covers booking date
        Contract activeContract = contractRepository.findByMemberIdAndStatusAndDateRange(
                dto.getMemberId(),
                ContractStatusEnum.ACTIVE,
                dto.getBookingDate())
                .orElseThrow(() -> new IllegalArgumentException(
                        "Thành viên không có hợp đồng hoạt động hợp lệ cho ngày đặt lịch này"));

        // Step 3: Validate PT exists
        PersonalTrainer pt = personalTrainerRepository.findById(dto.getPtId())
                .orElseThrow(() -> new IllegalArgumentException("PT không tồn tại"));

        // Step 4: Validate slot exists
        Slot slot = slotRepository.findById(dto.getSlotId())
                .orElseThrow(() -> new IllegalArgumentException("Khung giờ không tồn tại"));

        // Step 5: Check for duplicate booking
        boolean isDuplicate = bookingRepository.findByRealPtIdAndSlotIdAndBookingDate(
                dto.getPtId(),
                dto.getSlotId(),
                dto.getBookingDate())
                .isPresent();

        if (isDuplicate) {
            throw new IllegalArgumentException("Khung giờ này đã được đặt cho PT này rồi");
        }

        // Step 6: Create and save booking
        Booking booking = Booking.builder()
                .contract(activeContract)
                .member(member)
                .realPt(pt)
                .slot(slot)
                .bookingDate(dto.getBookingDate())
                .build();

        Booking savedBooking = bookingRepository.save(booking);

        // Step 7: Return response DTO
        return mapToResponseDTO(savedBooking);
    }

    /**
     * Get all bookings for a member
     */
    @Transactional(readOnly = true)
    public List<ResBookingDTO> getBookingsByMember(Long memberId) {
        return bookingRepository.findByMemberId(memberId)
                .stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Get all bookings for a PT
     */
    @Transactional(readOnly = true)
    public List<ResBookingDTO> getBookingsByPT(Long ptId) {
        return bookingRepository.findByRealPtId(ptId)
                .stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Get booking by ID
     */
    @Transactional(readOnly = true)
    public ResBookingDTO getBookingById(Long bookingId) {
        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> new IllegalArgumentException("Booking không tồn tại"));
        return mapToResponseDTO(booking);
    }

    /**
     * Delete a booking
     */
    @Transactional
    public void deleteBooking(Long bookingId) {
        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> new IllegalArgumentException("Booking không tồn tại"));
        bookingRepository.delete(booking);
    }

    /**
     * Map Booking entity to response DTO
     */
    private ResBookingDTO mapToResponseDTO(Booking booking) {
        return ResBookingDTO.builder()
                .id(booking.getId())
                .contractId(booking.getContract().getId())
                .memberId(booking.getMember().getId())
                .memberName(booking.getMember().getUser().getFullname())
                .ptId(booking.getRealPt() != null ? booking.getRealPt().getId() : null)
                .ptName(booking.getRealPt() != null ? booking.getRealPt().getUser().getFullname() : null)
                .slotId(booking.getSlot().getId())
                .slotStartTime(booking.getSlot().getStartTime())
                .slotEndTime(booking.getSlot().getEndTime())
                .bookingDate(booking.getBookingDate())
                .createdBy(booking.getCreatedBy())
                .build();
    }
}
