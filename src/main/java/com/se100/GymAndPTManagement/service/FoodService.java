package com.se100.GymAndPTManagement.service;

import java.math.BigDecimal;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.se100.GymAndPTManagement.domain.requestDTO.ReqCreateFoodDTO;
import com.se100.GymAndPTManagement.domain.requestDTO.ReqUpdateFoodDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResFoodDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResultPaginationDTO;
import com.se100.GymAndPTManagement.domain.table.Food;
import com.se100.GymAndPTManagement.repository.FoodRepository;

/**
 * Generated by: GitHub Copilot (Claude Sonnet 4.5)
 * Created by: PhDuy2005
 * Created at: 2026-01-15 14:30:00
 * Purpose: Food service for business logic
 */
@Service
public class FoodService {

    private final FoodRepository foodRepository;
    Logger logger = Logger.getLogger(FoodService.class.getName());

    public FoodService(FoodRepository foodRepository) {
        this.foodRepository = foodRepository;
    }

    // =========================================
    // Conversion Helpers
    // =========================================

    private ResFoodDTO convertToDTO(Food food) {
        return ResFoodDTO.builder()
                .id(food.getId())
                .name(food.getName())
                .description(food.getDescription())
                .calories(food.getCalories())
                .proteinG(food.getProtein())
                .carbsG(food.getCarbohydrate())
                .fatG(food.getFat())
                .note(food.getNotes())
                .type(food.getType()) // Tự động tính từ macro lớn nhất
                .createdAt(food.getCreatedAt())
                .updatedAt(food.getUpdatedAt())
                .build();
    }

    // =========================================
    // CRUD Methods
    // =========================================

    /**
     * Create new food
     * 
     * @param request DTO containing food creation info
     * @return Response DTO with created food data
     * @throws IllegalArgumentException if name already exists
     */
    @Transactional
    public ResFoodDTO createFood(ReqCreateFoodDTO request) {
        // Validate name không trùng
        if (foodRepository.existsByName(request.getName())) {
            logger.warning(">>>FOOD SERVICE - CREATE FOOD: Name already exists - " + request.getName());
            throw new IllegalArgumentException("Tên thực phẩm đã tồn tại trong hệ thống");
        }

        // Create food entity (calories sẽ tự động tính trong @PrePersist)
        Food food = Food.builder()
                .name(request.getName())
                .description(request.getDescription())
                .protein(request.getProteinG())
                .carbohydrate(request.getCarbsG())
                .fat(request.getFatG())
                .notes(request.getNote())
                .build();

        food = foodRepository.save(food);
        logger.info(">>>FOOD SERVICE - CREATE FOOD: Food created successfully with ID " + food.getId()
                + ", Calories: " + food.getCalories() + ", Type: " + food.getType());

        return convertToDTO(food);
    }

    /**
     * Get food by ID
     * 
     * @param id Food ID
     * @return Response DTO with food data
     * @throws NoSuchElementException if food not found
     */
    public ResFoodDTO getFoodById(Long id) {
        Food food = foodRepository.findById(id)
                .orElseThrow(() -> {
                    logger.warning(">>>FOOD SERVICE - GET FOOD BY ID: Food not found with ID " + id);
                    return new NoSuchElementException("Không tìm thấy thực phẩm với ID: " + id);
                });

        return convertToDTO(food);
    }

    /**
     * Get all foods
     * 
     * @return List of all foods
     */
    public List<ResFoodDTO> getAllFoods() {
        return foodRepository.findAll().stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    /**
     * Fetch foods with filter and pagination
     * 
     * @param specification Filter specification
     * @param pageable      Pagination info
     * @return Paginated result
     */
    public ResultPaginationDTO handleFetchFoods(Specification<Food> specification, Pageable pageable) {
        Page<Food> foodPage = foodRepository.findAll(specification, pageable);

        ResultPaginationDTO.Meta meta = ResultPaginationDTO.Meta.builder()
                .page(pageable.getPageNumber() + 1)
                .pageSize(pageable.getPageSize())
                .totalPages(foodPage.getTotalPages())
                .totalItems(foodPage.getTotalElements())
                .build();

        List<ResFoodDTO> foodDTOs = foodPage.getContent().stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());

        ResultPaginationDTO res = new ResultPaginationDTO();
        res.setMeta(meta);
        res.setResult(foodDTOs);
        return res;
    }

    /**
     * Get active foods only
     * 
     * @return List of active foods
     */
    public List<ResFoodDTO> getActiveFoods() {
        return foodRepository.findByStatus("ACTIVE").stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    /**
     * Search foods by keyword
     *
     * @param keyword  Search keyword
     * @param pageable Pagination info
     * @return Paginated search result
     */
    public ResultPaginationDTO searchFoods(String keyword, Pageable pageable) {
        Page<Food> foodPage = foodRepository.findByNameContainingIgnoreCase(keyword, pageable);

        ResultPaginationDTO.Meta meta = ResultPaginationDTO.Meta.builder()
                .page(pageable.getPageNumber() + 1)
                .pageSize(pageable.getPageSize())
                .totalPages(foodPage.getTotalPages())
                .totalItems(foodPage.getTotalElements())
                .build();

        List<ResFoodDTO> foodDTOs = foodPage.getContent().stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());

        ResultPaginationDTO res = new ResultPaginationDTO();
        res.setMeta(meta);
        res.setResult(foodDTOs);
        return res;
    }

    public ResultPaginationDTO getFoodsByType(String type, Pageable pageable) {
        Page<Food> foodPage = foodRepository.findByType(type, pageable);

        ResultPaginationDTO.Meta meta = ResultPaginationDTO.Meta.builder()
                .page(pageable.getPageNumber() + 1)
                .pageSize(pageable.getPageSize())
                .totalPages(foodPage.getTotalPages())
                .totalItems(foodPage.getTotalElements())
                .build();

        List<ResFoodDTO> foodDTOs = foodPage.getContent().stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());

        ResultPaginationDTO res = new ResultPaginationDTO();
        res.setMeta(meta);
        res.setResult(foodDTOs);
        return res;
    }

    /**
     * Get foods by calories range
     *
     * @param minCalories Minimum calories
     * @param maxCalories Maximum calories
     * @param pageable    Pagination info
     * @return Paginated result
     */
    public ResultPaginationDTO getFoodsByCaloriesRange(BigDecimal minCalories,
            BigDecimal maxCalories,
            Pageable pageable) {
        Page<Food> foodPage = foodRepository.findByCaloriesBetween(minCalories,
                maxCalories, pageable);

        ResultPaginationDTO.Meta meta = ResultPaginationDTO.Meta.builder()
                .page(pageable.getPageNumber() + 1)
                .pageSize(pageable.getPageSize())
                .totalPages(foodPage.getTotalPages())
                .totalItems(foodPage.getTotalElements())
                .build();

        List<ResFoodDTO> foodDTOs = foodPage.getContent().stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());

        ResultPaginationDTO res = new ResultPaginationDTO();
        res.setMeta(meta);
        res.setResult(foodDTOs);
        return res;
    }

    /**
     * Get top protein foods
     * 
     * @param limit Number of results
     * @return List of top protein foods
     */
    public List<ResFoodDTO> getTopProteinFoods(int limit) {
        Pageable pageable = PageRequest.of(0, limit, Sort.by(Sort.Direction.DESC, "proteinG"));
        Page<Food> foodPage = foodRepository.findAll(pageable);

        return foodPage.getContent().stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    /**
     * Get top carbohydrate foods
     * 
     * @param limit Number of results
     * @return List of top carb foods
     */
    public List<ResFoodDTO> getTopCarbFoods(int limit) {
        Pageable pageable = PageRequest.of(0, limit, Sort.by(Sort.Direction.DESC, "carbsG"));
        Page<Food> foodPage = foodRepository.findAll(pageable);

        return foodPage.getContent().stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    /**
     * Get top fat foods
     * 
     * @param limit Number of results
     * @return List of top fat foods
     */
    public List<ResFoodDTO> getTopFatFoods(int limit) {
        Pageable pageable = PageRequest.of(0, limit, Sort.by(Sort.Direction.DESC, "fatG"));
        Page<Food> foodPage = foodRepository.findAll(pageable);

        return foodPage.getContent().stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    /**
     * Update food
     * 
     * @param id      Food ID
     * @param request Update request DTO
     * @return Updated food DTO
     * @throws NoSuchElementException if food not found
     */
    @Transactional
    public ResFoodDTO updateFood(Long id, ReqUpdateFoodDTO request) {
        Food food = foodRepository.findById(id)
                .orElseThrow(() -> {
                    logger.warning(">>>FOOD SERVICE - UPDATE FOOD: Food not found with ID " + id);
                    return new NoSuchElementException("Không tìm thấy thực phẩm với ID: " + id);
                });

        // Update fields if provided
        if (request.getName() != null && !request.getName().isEmpty()) {
            // Check if new name already exists (excluding current food)
            if (foodRepository.existsByName(request.getName()) && !food.getName().equals(request.getName())) {
                logger.warning(">>>FOOD SERVICE - UPDATE FOOD: Name already exists - " + request.getName());
                throw new IllegalArgumentException("Tên thực phẩm đã tồn tại trong hệ thống");
            }
            food.setName(request.getName());
        }

        if (request.getDescription() != null) {
            food.setDescription(request.getDescription());
        }

        if (request.getProteinG() != null) {
            food.setProtein(request.getProteinG());
        }

        if (request.getCarbsG() != null) {
            food.setCarbohydrate(request.getCarbsG());
        }

        if (request.getFatG() != null) {
            food.setFat(request.getFatG());
        }

        if (request.getNote() != null) {
            food.setNotes(request.getNote());
        }

        // Calories sẽ tự động tính lại trong @PreUpdate
        food = foodRepository.save(food);
        logger.info(">>>FOOD SERVICE - UPDATE FOOD: Food updated successfully with ID " + food.getId()
                + ", New Calories: " + food.getCalories() + ", Type: " + food.getType());

        return convertToDTO(food);
    }

    /**
     * Delete food
     * 
     * @param id Food ID
     * @throws NoSuchElementException if food not found
     */
    @Transactional
    public void deleteFood(Long id) {
        Food food = foodRepository.findById(id)
                .orElseThrow(() -> {
                    logger.warning(">>>FOOD SERVICE - DELETE FOOD: Food not found with ID " + id);
                    return new NoSuchElementException("Không tìm thấy thực phẩm với ID: " + id);
                });

        foodRepository.delete(food);
        logger.info(">>>FOOD SERVICE - DELETE FOOD: Food deleted with ID " + id);
    }
}
