package com.se100.GymAndPTManagement.service;

import java.math.BigDecimal;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.se100.GymAndPTManagement.domain.requestDTO.ReqCreatePTDTO;
import com.se100.GymAndPTManagement.domain.requestDTO.ReqUpdatePTDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResPTDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResUserDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResultPaginationDTO;
import com.se100.GymAndPTManagement.domain.table.AvailableSlot;
import com.se100.GymAndPTManagement.domain.table.PersonalTrainer;
import com.se100.GymAndPTManagement.domain.table.Role;
import com.se100.GymAndPTManagement.domain.table.Slot;
import com.se100.GymAndPTManagement.domain.table.User;
import com.se100.GymAndPTManagement.repository.AvailableSlotRepository;
import com.se100.GymAndPTManagement.repository.PersonalTrainerRepository;
import com.se100.GymAndPTManagement.repository.RoleRepository;
import com.se100.GymAndPTManagement.repository.SlotRepository;
import com.se100.GymAndPTManagement.repository.UserRepository;
import com.se100.GymAndPTManagement.util.enums.DayOfWeekEnum;
import com.se100.GymAndPTManagement.util.enums.PTStatusEnum;
import com.se100.GymAndPTManagement.util.enums.UserStatusEnum;

/**
 * Generated by: GitHub Copilot (Claude Sonnet 4.5)
 * Created by: PhDuy2005
 * Created at: 2026-01-08 11:20:37
 * Purpose: PersonalTrainer service for business logic
 */
@Service
public class PersonalTrainerService {

    private final PersonalTrainerRepository ptRepository;
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;
    private final AvailableSlotRepository availableSlotRepository;
    private final SlotRepository slotRepository;

    public PersonalTrainerService(PersonalTrainerRepository ptRepository, UserRepository userRepository,
            RoleRepository roleRepository, PasswordEncoder passwordEncoder, AvailableSlotRepository availableSlotRepository,
            SlotRepository slotRepository) {
        this.ptRepository = ptRepository;
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.passwordEncoder = passwordEncoder;
        this.availableSlotRepository = availableSlotRepository;
        this.slotRepository = slotRepository;
    }

    private boolean isActivePT(PersonalTrainer pt) {
        return pt.getUser().getStatus() == UserStatusEnum.ACTIVE;
    }

    private boolean isAvailablePT(PersonalTrainer pt) {
        return pt.getStatus() == PTStatusEnum.AVAILABLE;
    }

    private boolean isBusyPT(PersonalTrainer pt) {
        return pt.getStatus() == PTStatusEnum.BUSY;
    }

    public ResPTDTO setAvailablePT(Long ptId) {
        PersonalTrainer pt = ptRepository.findById(ptId)
                .orElseThrow(() -> new NoSuchElementException("Không tìm thấy PT với ID: " + ptId));
        if (!isActivePT(pt)) {
            throw new IllegalStateException("Personal Trainer is not active");
        }
        if (isAvailablePT(pt)) {
            throw new IllegalStateException("Personal Trainer is already available");
        }
        pt.setStatus(PTStatusEnum.AVAILABLE);
        PersonalTrainer updatedPT = ptRepository.save(pt);
        return convertToDTO(updatedPT);
    }

    public ResPTDTO setBusyPT(Long ptId) {
        PersonalTrainer pt = ptRepository.findById(ptId)
                .orElseThrow(() -> new NoSuchElementException("Không tìm thấy PT với ID: " + ptId));
        if (!isActivePT(pt)) {
            throw new IllegalStateException("Personal Trainer is not active");
        }
        if (isBusyPT(pt)) {
            throw new IllegalStateException("Personal Trainer is already busy");
        }
        pt.setStatus(PTStatusEnum.BUSY);
        PersonalTrainer updatedPT = ptRepository.save(pt);
        return convertToDTO(updatedPT);
    }

    /**
     * Get all available PTs by time slot and date
     * 
     * @param slotId ID of the time slot
     * @param date   Date to check availability
     * @return List of available PTs
     */
    public List<ResPTDTO> getAvailablePTsBySlotAndDate(Long slotId, LocalDate date) {
        // Validate slot exists
        Slot slot = slotRepository.findById(slotId)
                .orElseThrow(() -> new NoSuchElementException("Slot not found with id: " + slotId));

        // Get day of week from date
        DayOfWeek dayOfWeek = date.getDayOfWeek();
        DayOfWeekEnum dayOfWeekEnum = DayOfWeekEnum.valueOf(dayOfWeek.name());

        // Find all available slots for this slot ID and day of week
        List<AvailableSlot> availableSlots = availableSlotRepository
                .findBySlotIdAndDayOfWeekAndIsAvailable(slotId, dayOfWeekEnum, true);

        // Extract PTs and filter by active status
        return availableSlots.stream()
                .map(AvailableSlot::getPersonalTrainer)
                .filter(this::isActivePT)
                .filter(this::isAvailablePT)
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    // =========================================
    // CRUD Methods
    // =========================================

    @Transactional
    public ResPTDTO createPT(ReqCreatePTDTO request) {
        // Validate email không trùng
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new IllegalArgumentException("Email đã tồn tại trong hệ thống");
        }

        // Get PT role
        Role ptRole = roleRepository.findByName("PT");
        if (ptRole == null) {
            throw new IllegalArgumentException("PT role not found in the system");
        }

        // Tạo User entity
        String finalPassword = (request.getPassword() == null || request.getPassword().trim().isEmpty())
                ? "12345678"
                : request.getPassword();

        User user = User.builder()
                .fullname(request.getFullname())
                .email(request.getEmail())
                .passwordHash(passwordEncoder.encode(finalPassword))
                .phoneNumber(request.getPhoneNumber())
                .avatarUrl(request.getAvatarUrl())
                .dob(request.getDob())
                .gender(request.getGender())
                .status(request.getStatus() != null ? request.getStatus() : UserStatusEnum.ACTIVE)
                .role(ptRole)
                .build();

        // Save User
        User savedUser = userRepository.save(user);
        System.out.println(">>>PT SERVICE - CREATE PT: User created with ID " + savedUser.getId() + " and PT role.");

        // Tạo PersonalTrainer entity
        PersonalTrainer pt = PersonalTrainer.builder()
                .user(savedUser)
                .about(request.getAbout())
                .specialization(request.getSpecialization())
                .certifications(request.getCertifications())
                .experienceYears(request.getExperienceYears())
                .note(request.getNote())
                .build();
        // rating, status, experienceYears sẽ được set trong @PrePersist

        // Save PersonalTrainer
        PersonalTrainer savedPT = ptRepository.save(pt);
        System.out.println(">>>PT SERVICE - CREATE PT: Personal Trainer created with ID " + savedPT.getId());

        // Convert to DTO
        return convertToDTO(savedPT);
    }

    @Transactional
    public List<ResPTDTO> getAllPTs() {
        List<PersonalTrainer> pts = ptRepository.findAll();
        System.out.println(">>>PT SERVICE - GET ALL PTS: Retrieved " + pts.size() + " personal trainers.");
        return pts.stream()
                .map(this::convertToDTO)
                .toList();
    }

    /**
     * Fetch personal trainers with pagination and filter
     */
    @Transactional(readOnly = true)
    public ResultPaginationDTO handleFetchPTs(Specification<PersonalTrainer> specification, Pageable pageable) {
        Page<PersonalTrainer> pagePTs = ptRepository.findAll(specification, pageable);
        ResultPaginationDTO resultPaginationDTO = new ResultPaginationDTO();
        ResultPaginationDTO.Meta meta = ResultPaginationDTO.Meta.builder()
                .page(pageable.getPageNumber() + 1)
                .pageSize(pageable.getPageSize())
                .totalPages(pagePTs.getTotalPages())
                .totalItems(pagePTs.getTotalElements())
                .build();

        resultPaginationDTO.setMeta(meta);
        List<ResPTDTO> result = pagePTs.getContent()
                .stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
        resultPaginationDTO.setResult(result);
        return resultPaginationDTO;
    }

    @Transactional
    public List<ResPTDTO> getAllActivePTs() {
        List<PersonalTrainer> pts = ptRepository.findAll();
        System.out.println(">>>PT SERVICE - GET ALL ACTIVE PTS: Retrieved " + pts.size() + " personal trainers.");
        return pts.stream()
                .filter(this::isActivePT)
                .map(this::convertToDTO)
                .toList();
    }

    @Transactional
    public ResPTDTO getPTById(Long ptId) {
        PersonalTrainer pt = ptRepository.findById(ptId)
                .orElseThrow(() -> new NoSuchElementException("Không tìm thấy PT với ID: " + ptId));
        System.out.println(">>>PT SERVICE - GET PT BY ID: Found personal trainer with ID " + ptId);
        return convertToDTO(pt);
    }

    @Transactional
    public ResPTDTO getPTByEmail(String email) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new NoSuchElementException("Không tìm thấy PT với email: " + email));
        PersonalTrainer pt = ptRepository.findByUserId(user.getId())
                .orElseThrow(() -> new NoSuchElementException("Không tìm thấy PT với email: " + email));
        System.out.println(">>>PT SERVICE - GET PT BY EMAIL: Found personal trainer with email " + email);
        return convertToDTO(pt);
    }

    @Transactional
    public ResPTDTO updatePT(Long ptId, ReqUpdatePTDTO request) {
        PersonalTrainer pt = ptRepository.findById(ptId)
                .orElseThrow(() -> new NoSuchElementException("Không tìm thấy PT với ID: " + ptId));

        User user = pt.getUser();

        // Cập nhật thông tin User
        if (request.getFullname() != null && !request.getFullname().isEmpty()) {
            user.setFullname(request.getFullname());
        }

        if (request.getEmail() != null && !request.getEmail().isEmpty()) {
            // Kiểm tra email mới không trùng với user khác
            if (!user.getEmail().equals(request.getEmail()) && userRepository.existsByEmail(request.getEmail())) {
                throw new RuntimeException("Email đã tồn tại trong hệ thống");
            }
            user.setEmail(request.getEmail());
        }

        if (request.getPhoneNumber() != null) {
            user.setPhoneNumber(request.getPhoneNumber());
        }

        if (request.getAvatarUrl() != null) {
            user.setAvatarUrl(request.getAvatarUrl());
        }

        if (request.getDob() != null) {
            user.setDob(request.getDob());
        }

        if (request.getGender() != null) {
            user.setGender(request.getGender());
        }

        // Cập nhật thông tin PT
        if (request.getAbout() != null) {
            pt.setAbout(request.getAbout());
        }

        if (request.getSpecialization() != null) {
            pt.setSpecialization(request.getSpecialization());
        }

        if (request.getCertifications() != null) {
            pt.setCertifications(request.getCertifications());
        }

        if (request.getExperienceYears() != null) {
            pt.setExperienceYears(request.getExperienceYears());
        }

        if (request.getNote() != null) {
            pt.setNote(request.getNote());
        }

        System.out.println(">>>PT SERVICE - UPDATE PT: PT information updated.");

        // Save User và PT
        userRepository.save(user);
        PersonalTrainer updatedPT = ptRepository.save(pt);

        return convertToDTO(updatedPT);
    }

    @Transactional
    public void deletePT(Long ptId) {
        PersonalTrainer pt = ptRepository.findById(ptId)
                .orElseThrow(() -> new NoSuchElementException("Không tìm thấy PT với ID: " + ptId));

        System.out.println(">>>PT SERVICE - DELETE PT: Setting PT and User status to INACTIVE.");
        User user = pt.getUser();
        user.setStatus(UserStatusEnum.INACTIVE);
        pt.setStatus(PTStatusEnum.INACTIVE);

        userRepository.save(user);
        ptRepository.save(pt);
    }

    // =========================================
    // Mapper
    // =========================================
    private ResPTDTO convertToDTO(PersonalTrainer pt) {
        ResUserDTO userDTO = ResUserDTO.builder()
                .id(pt.getUser().getId())
                .fullname(pt.getUser().getFullname())
                .email(pt.getUser().getEmail())
                .phoneNumber(pt.getUser().getPhoneNumber())
                .avatarUrl(pt.getUser().getAvatarUrl())
                .dob(pt.getUser().getDob())
                .gender(pt.getUser().getGender())
                .status(pt.getUser().getStatus())
                .build();

        return ResPTDTO.builder()
                .id(pt.getId())
                .user(userDTO)
                .about(pt.getAbout())
                .specialization(pt.getSpecialization())
                .certifications(pt.getCertifications())
                .experienceYears(pt.getExperienceYears())
                .rating(pt.getRating())
                .status(pt.getStatus())
                .note(pt.getNote())
                .createdAt(pt.getCreatedAt())
                .updatedAt(pt.getUpdatedAt())
                .build();
    }
}
