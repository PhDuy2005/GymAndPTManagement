/**
 * Generated by: GitHub Copilot (Claude Haiku 4.5)
 * Created by: KStuv
 * Created at: 2026-01-14 11:10:00
 * Purpose: Service for Checkin Log management with business logic
 */
package com.se100.GymAndPTManagement.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.se100.GymAndPTManagement.domain.table.Booking;
import com.se100.GymAndPTManagement.domain.table.CheckinLog;
import com.se100.GymAndPTManagement.domain.table.Contract;
import com.se100.GymAndPTManagement.domain.requestDTO.ReqCheckinDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResCheckinLogDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResAttendanceTrackingDTO;
import com.se100.GymAndPTManagement.repository.BookingRepository;
import com.se100.GymAndPTManagement.repository.CheckinLogRepository;
import com.se100.GymAndPTManagement.repository.ContractRepository;

import lombok.RequiredArgsConstructor;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class CheckinLogService {

    private final CheckinLogRepository checkinLogRepository;
    private final BookingRepository bookingRepository;
    private final ContractRepository contractRepository;

    /**
     * Create check-in log when member arrives
     * 
     * Business Logic:
     * 1. Validate booking exists
     * 2. Check if booking already has active checkin (not cancelled)
     * 3. Create new checkin log with CHECKED_IN status
     * 
     * @param dto Check-in request DTO
     * @return Created checkin log response
     * @throws IllegalArgumentException if validation fails
     */
    @Transactional
    public ResCheckinLogDTO checkIn(ReqCheckinDTO dto) {
        // Step 1: Validate booking exists
        Booking booking = bookingRepository.findById(dto.getBookingId())
                .orElseThrow(() -> new IllegalArgumentException("Booking không tồn tại"));

        // Step 2: Check if booking already has active checkin
        if (checkinLogRepository.hasActiveCheckin(dto.getBookingId())) {
            throw new IllegalArgumentException("Booking này đã được check-in rồi");
        }

        // Step 3: Create new checkin log
        CheckinLog checkinLog = CheckinLog.builder()
                .booking(booking)
                .member(booking.getMember())
                .checkinTime(LocalTime.now())
                .status("CHECKED_IN")
                .checkoutTime(null)
                .build();

        CheckinLog savedLog = checkinLogRepository.save(checkinLog);

        // Step 4: Return response DTO
        return mapToResponseDTO(savedLog);
    }

    /**
     * Update check-out time when member finishes workout
     * 
     * Business Logic:
     * 1. Find active checkin log (CHECKED_IN status) by booking ID
     * 2. Update checkout_time and status to CHECKED_OUT
     * 3. Save changes
     * 
     * @param bookingId Booking ID to identify the checkin log
     * @return Updated checkin log response
     * @throws IllegalArgumentException if log not found or multiple logs found
     */
    @Transactional
    public ResCheckinLogDTO checkOut(Long bookingId) {
        // Step 1: Find active checkin log
        CheckinLog checkinLog = checkinLogRepository.findActiveCheckInByBookingId(bookingId)
                .orElseThrow(() -> new IllegalArgumentException(
                        "Không tìm thấy check-in log đang hoạt động cho booking này"));

        // Step 2: Update checkout time and status
        checkinLog.setCheckoutTime(LocalTime.now());
        checkinLog.setStatus("CHECKED_OUT");

        // Step 3: Save changes
        CheckinLog updatedLog = checkinLogRepository.save(checkinLog);

        // Step 4: Return response DTO
        return mapToResponseDTO(updatedLog);
    }

    /**
     * Cancel a checkin log when admin makes a mistake or booking is cancelled
     * 
     * Business Logic:
     * 1. Find latest checkin log by booking ID
     * 2. Get the associated booking and contract
     * 3. Update checkin status to CANCELLED
     * 4. Restore remaining_sessions of the contract (increase by 1)
     * 5. Save changes to both checkin log and contract
     * 
     * @param bookingId Booking ID to identify the checkin log
     * @return Updated checkin log response
     * @throws IllegalArgumentException if log or booking not found
     */
    @Transactional
    public ResCheckinLogDTO cancelCheckin(Long bookingId) {
        // Step 1: Find latest checkin log
        CheckinLog checkinLog = checkinLogRepository.findLatestByBookingId(bookingId)
                .orElseThrow(() -> new IllegalArgumentException(
                        "Không tìm thấy check-in log cho booking này"));

        // Step 2: Get the associated booking and contract
        Booking booking = bookingRepository.findById(bookingId)
                .orElseThrow(() -> new IllegalArgumentException("Booking không tồn tại"));
        
        Contract contract = booking.getContract();

        // Step 3: Update status to CANCELLED
        checkinLog.setStatus("CANCELLED");

        // Step 4: Restore remaining_sessions by incrementing by 1
        // Only restore if contract has remaining_sessions tracking and not already at max
        if (contract.getRemainingSessions() != null && contract.getRemainingSessions() < contract.getTotalSessions()) {
            contract.setRemainingSessions(contract.getRemainingSessions() + 1);
            contractRepository.save(contract);
        }

        // Step 5: Save changes to checkin log
        CheckinLog updatedLog = checkinLogRepository.save(checkinLog);

        // Step 6: Return response DTO
        return mapToResponseDTO(updatedLog);
    }

    /**
     * Get all checkin logs by member ID
     */
    @Transactional(readOnly = true)
    public List<ResCheckinLogDTO> getCheckinsByMember(Long memberId) {
        return checkinLogRepository.findByMemberId(memberId)
                .stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Get all checkin logs by booking ID
     */
    @Transactional(readOnly = true)
    public List<ResCheckinLogDTO> getCheckinsByBooking(Long bookingId) {
        return checkinLogRepository.findByBookingId(bookingId)
                .stream()
                .map(this::mapToResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Get checkin log by ID
     */
    @Transactional(readOnly = true)
    public ResCheckinLogDTO getCheckinById(Long checkinId) {
        CheckinLog checkinLog = checkinLogRepository.findById(checkinId)
                .orElseThrow(() -> new IllegalArgumentException("Checkin log không tồn tại"));
        return mapToResponseDTO(checkinLog);
    }

    /**
     * Get attendance tracking statistics for a member
     * 
     * Business Logic:
     * 1. Get member's active contracts (latest one)
     * 2. Calculate totalSessions and remainingSessions from contract
     * 3. Calculate bookedSessions = totalSessions - remainingSessions
     * 4. Count attendedSessions = CheckinLog records with status = 'CHECKED_OUT'
     * 5. Calculate attendanceRate = (attendedSessions / bookedSessions) * 100
     * 
     * @param memberId Member ID
     * @return Attendance tracking statistics
     * @throws IllegalArgumentException if member or contract not found
     */
    @Transactional(readOnly = true)
    public ResAttendanceTrackingDTO getAttendanceTracking(Long memberId) {
        // Step 1: Get member's active contracts
        // For simplicity, we get the most recent contract with sessions info
        List<Contract> memberContracts = contractRepository.findByMemberId(memberId);
        
        if (memberContracts.isEmpty()) {
            throw new IllegalArgumentException("Thành viên không có hợp đồng nào");
        }
        
        // Get the most recent contract (assuming contracts are ordered by creation)
        Contract latestContract = memberContracts.get(memberContracts.size() - 1);
        
        // Step 2: Extract session counts from contract
        Integer totalSessions = latestContract.getTotalSessions() != null ? latestContract.getTotalSessions() : 0;
        Integer remainingSessions = latestContract.getRemainingSessions() != null ? latestContract.getRemainingSessions() : 0;
        
        // Step 3: Calculate booked sessions
        Integer bookedSessions = totalSessions - remainingSessions;
        if (bookedSessions < 0) {
            bookedSessions = 0;
        }
        
        // Step 4: Count attended sessions
        Long attendedSessionsCount = checkinLogRepository.countAttendedSessionsByMemberId(memberId);
        Integer attendedSessions = attendedSessionsCount != null ? attendedSessionsCount.intValue() : 0;
        
        // Step 5: Calculate attendance rate
        BigDecimal attendanceRate = null;
        String attendancePercentage = "0%";
        
        if (bookedSessions > 0) {
            attendanceRate = new BigDecimal(attendedSessions)
                    .divide(new BigDecimal(bookedSessions), 4, RoundingMode.HALF_UP)
                    .multiply(new BigDecimal(100));
            
            attendancePercentage = attendanceRate.setScale(2, RoundingMode.HALF_UP).toString() + "%";
        }
        
        // Step 6: Build and return response DTO
        return ResAttendanceTrackingDTO.builder()
                .memberId(memberId)
                .memberName(latestContract.getMember().getUser().getFullname())
                .totalSessions(totalSessions)
                .remainingSessions(remainingSessions)
                .bookedSessions(bookedSessions)
                .attendedSessions(attendedSessions)
                .attendanceRate(attendanceRate)
                .attendancePercentage(attendancePercentage)
                .build();
    }

    /**
     * Map CheckinLog entity to response DTO
     */
    private ResCheckinLogDTO mapToResponseDTO(CheckinLog checkinLog) {
        return ResCheckinLogDTO.builder()
                .checkinId(checkinLog.getId())
                .bookingId(checkinLog.getBooking() != null ? checkinLog.getBooking().getId() : null)
                .memberId(checkinLog.getMember().getId())
                .memberName(checkinLog.getMember().getUser().getFullname())
                .checkinTime(checkinLog.getCheckinTime())
                .checkoutTime(checkinLog.getCheckoutTime())
                .status(checkinLog.getStatus())
                .createdBy(checkinLog.getCreatedBy())
                .build();
    }
}
