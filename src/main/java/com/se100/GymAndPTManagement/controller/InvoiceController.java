/**
 * Generated by: GitHub Copilot (Claude Haiku 4.5)
 * Created by: KStuv
 * Created at: 2026-01-16
 * Purpose: Controller for invoice operations and additional service order processing
 */
package com.se100.GymAndPTManagement.controller;

import com.se100.GymAndPTManagement.domain.requestDTO.ReqCreateAdditionalServiceInvoiceDTO;
import com.se100.GymAndPTManagement.domain.requestDTO.ReqUpdateInvoiceDTO;
import com.se100.GymAndPTManagement.domain.responseDTO.ResInvoiceDTO;
import com.se100.GymAndPTManagement.service.InvoiceService;
import com.se100.GymAndPTManagement.util.annotation.ApiMessage;
import com.se100.GymAndPTManagement.util.FormatRestResponse;
import com.se100.GymAndPTManagement.domain.responseDTO.RestResponse;
import com.se100.GymAndPTManagement.util.enums.PaymentStatusEnum;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jakarta.validation.Valid;
import java.util.List;

import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;

@RestController
@RequestMapping("/api/v1/invoices")
@Tag(name = "Invoice Management", description = "APIs for managing invoices and payment tracking")
public class InvoiceController {
    
    private static final Logger logger = LoggerFactory.getLogger(InvoiceController.class);
    private final InvoiceService invoiceService;
    
    public InvoiceController(InvoiceService invoiceService) {
        this.invoiceService = invoiceService;
    }
    
    /**
     * Create invoice for additional service order
     * POST /api/v1/invoices/additional-service
     * 
     * @param request - ReqCreateAdditionalServiceInvoiceDTO with additionalServiceId, memberId, quantity, discount, paymentMethod
     * @return - ResInvoiceDTO with invoice details
     */
    @PostMapping("/additional-service")
    @ApiMessage("Create invoice for additional service")
    @Operation(summary = "Create invoice for additional service", description = "Generate invoice for additional service order with automatic status update")
    @ApiResponses({
            @ApiResponse(responseCode = "201", description = "Invoice created successfully"),
            @ApiResponse(responseCode = "400", description = "Invalid service or member data"),
            @ApiResponse(responseCode = "404", description = "Service or member not found")
    })
    public ResponseEntity<RestResponse<ResInvoiceDTO>> createInvoiceForAdditionalService(
            @Valid @RequestBody ReqCreateAdditionalServiceInvoiceDTO request) {
        
        logger.info("POST /api/v1/invoices/additional-service - Creating invoice for service ID: {}, Member ID: {}",
                   request.getAdditionalServiceId(), request.getMemberId());
        
        try {
            ResInvoiceDTO invoice = invoiceService.createInvoiceForAdditionalService(request);
            
            logger.info("Invoice created successfully with ID: {}", invoice.getInvoiceId());
            
            return ResponseEntity.status(HttpStatus.CREATED)
                .body(FormatRestResponse.success(invoice, "Invoice created successfully for additional service"));
                
        } catch (IllegalArgumentException e) {
            logger.warn("Invalid request for creating invoice: {}", e.getMessage());
            return ResponseEntity.badRequest()
                .body(RestResponse.<ResInvoiceDTO>builder()
                    .statusCode(400)
                    .message("Invalid request: " + e.getMessage())
                    .build());
        } catch (Exception e) {
            logger.error("Error creating invoice", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(RestResponse.<ResInvoiceDTO>builder()
                    .statusCode(500)
                    .message("Internal server error")
                    .build());
        }
    }
    
    /**
     * Get invoice by ID
     * GET /api/v1/invoices/{id}
     * 
     * @param id - Invoice ID
     * @return - ResInvoiceDTO
     */
    @GetMapping("/{id}")
    @ApiMessage("Get invoice by ID")
    @Operation(summary = "Get invoice by ID", description = "Retrieve invoice details including payment information")
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Invoice retrieved successfully"),
            @ApiResponse(responseCode = "404", description = "Invoice not found")
    })
    public ResponseEntity<RestResponse<ResInvoiceDTO>> getInvoiceById(@PathVariable Long id) {
        
        logger.debug("GET /api/v1/invoices/{} - Fetching invoice", id);
        
        try {
            ResInvoiceDTO invoice = invoiceService.getInvoiceById(id);
            
            return ResponseEntity.ok(
                RestResponse.<ResInvoiceDTO>builder()
                    .statusCode(200)
                    .message("Invoice retrieved successfully")
                    .data(invoice)
                    .build());
                    
        } catch (IllegalArgumentException e) {
            logger.warn("Invoice not found with ID: {}", id);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(RestResponse.<ResInvoiceDTO>builder()
                    .statusCode(404)
                    .message("Invoice not found")
                    .build());
        } catch (Exception e) {
            logger.error("Error retrieving invoice with ID: {}", id, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(RestResponse.<ResInvoiceDTO>builder()
                    .statusCode(500)
                    .message("Internal server error")
                    .build());
        }
    }
    
    /**
     * Get all invoices
     * GET /api/v1/invoices
     * 
     * @return - List of ResInvoiceDTO
     */
    @GetMapping
    @ApiMessage("Get all invoices")
    @Operation(summary = "Get all invoices", description = "Retrieve all invoices from the system")
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "All invoices retrieved successfully"),
            @ApiResponse(responseCode = "500", description = "Server error")
    })
    public ResponseEntity<RestResponse<List<ResInvoiceDTO>>> getAllInvoices() {
        
        logger.debug("GET /api/v1/invoices - Fetching all invoices");
        
        try {
            List<ResInvoiceDTO> invoices = invoiceService.getAllInvoices();
            
            return ResponseEntity.ok(
                RestResponse.<List<ResInvoiceDTO>>builder()
                    .statusCode(200)
                    .message("All invoices retrieved successfully")
                    .data(invoices)
                    .build());
                    
        } catch (Exception e) {
            logger.error("Error retrieving all invoices", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(RestResponse.<List<ResInvoiceDTO>>builder()
                    .statusCode(500)
                    .message("Internal server error")
                    .build());
        }
    }
    
    /**
     * Get all invoices for a member
     * GET /api/v1/invoices/member/{memberId}
     * 
     * @param memberId - Member ID
     * @return - List of ResInvoiceDTO
     */
    @GetMapping("/member/{memberId}")
    @ApiMessage("Get invoices by member ID")
    public ResponseEntity<RestResponse<List<ResInvoiceDTO>>> getInvoicesByMemberId(
            @PathVariable Long memberId) {
        
        logger.debug("GET /api/v1/invoices/member/{} - Fetching invoices", memberId);
        
        try {
            List<ResInvoiceDTO> invoices = invoiceService.getInvoicesByMemberId(memberId);
            
            return ResponseEntity.ok(
                RestResponse.<List<ResInvoiceDTO>>builder()
                    .statusCode(200)
                    .message("Invoices retrieved successfully")
                    .data(invoices)
                    .build());
                    
        } catch (IllegalArgumentException e) {
            logger.warn("Invalid member ID: {}", memberId);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(RestResponse.<List<ResInvoiceDTO>>builder()
                    .statusCode(404)
                    .message("Member not found")
                    .build());
        } catch (Exception e) {
            logger.error("Error retrieving invoices for member ID: {}", memberId, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(RestResponse.<List<ResInvoiceDTO>>builder()
                    .statusCode(500)
                    .message("Internal server error")
                    .build());
        }
    }
    
    /**
     * Update payment status for invoice
     * PUT /api/v1/invoices/{id}/payment-status
     * 
     * @param id - Invoice ID
     * @param paymentStatus - New PaymentStatusEnum (UNPAID or PAID)
     * @return - Updated ResInvoiceDTO
     */
    @PutMapping("/{id}/payment-status")
    @ApiMessage("Update invoice payment status")
    public ResponseEntity<RestResponse<ResInvoiceDTO>> updatePaymentStatus(
            @PathVariable Long id,
            @RequestParam PaymentStatusEnum paymentStatus) {
        
        logger.info("PUT /api/v1/invoices/{}/payment-status - Updating to: {}", id, paymentStatus);
        
        try {
            ResInvoiceDTO updatedInvoice = invoiceService.updatePaymentStatus(id, paymentStatus);
            
            logger.info("Payment status updated successfully for invoice ID: {}", id);
            
            return ResponseEntity.ok(
                RestResponse.<ResInvoiceDTO>builder()
                    .statusCode(200)
                    .message("Payment status updated successfully")
                    .data(updatedInvoice)
                    .build());
                    
        } catch (IllegalArgumentException e) {
            logger.warn("Invoice not found with ID: {}", id);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(RestResponse.<ResInvoiceDTO>builder()
                    .statusCode(404)
                    .message("Invoice not found")
                    .build());
        } catch (Exception e) {
            logger.error("Error updating payment status for invoice ID: {}", id, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(RestResponse.<ResInvoiceDTO>builder()
                    .statusCode(500)
                    .message("Internal server error")
                    .build());
        }
    }

    /**
     * Delete invoice by ID (also deletes associated invoice details)
     * DELETE /api/v1/invoices/{id}
     * 
     * @param id - Invoice ID
     * @return - No content response
     */
    @DeleteMapping("/{id}")
    @ApiMessage("Xóa hóa đơn")
    @Operation(summary = "Delete invoice", description = "Delete an invoice and all associated invoice details by ID")
    @ApiResponses({
            @ApiResponse(responseCode = "204", description = "Invoice deleted successfully"),
            @ApiResponse(responseCode = "404", description = "Invoice not found")
    })
    public ResponseEntity<Void> deleteInvoice(@PathVariable Long id) {
        logger.info("DELETE /api/v1/invoices/{} - Deleting invoice", id);
        
        try {
            invoiceService.deleteInvoice(id);
            logger.info("Invoice deleted successfully with ID: {}", id);
            return ResponseEntity.noContent().build();
        } catch (IllegalArgumentException e) {
            logger.warn("Invoice not found with ID: {}", id);
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        } catch (Exception e) {
            logger.error("Error deleting invoice with ID: {}", id, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * Update invoice information with cascade update to invoice details
     * PUT /api/v1/invoices/{id}
     * 
     * @param id - Invoice ID
     * @param request - Update request with invoice and detail information
     * @return - Updated invoice response
     */
    @PutMapping("/{id}")
    @ApiMessage("Cập nhật hóa đơn")
    @Operation(
        summary = "Update invoice with cascade detail update",
        description = "Update invoice information and details. Automatically deletes all existing invoice details and creates new ones from the request. "
                    + "Recalculates invoice totals, applies discount, and updates payment method. Each detail can reference either a service package or additional service."
    )
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Invoice updated successfully with all details replaced"),
            @ApiResponse(responseCode = "400", description = "Validation error - empty details, discount exceeds total, or invalid service references"),
            @ApiResponse(responseCode = "404", description = "Invoice, member, service package, or additional service not found")
    })
    public ResponseEntity<RestResponse<ResInvoiceDTO>> updateInvoice(
            @PathVariable Long id,
            @Valid @RequestBody ReqUpdateInvoiceDTO request) {
        logger.info("PUT /api/v1/invoices/{} - Updating invoice", id);
        
        try {
            ResInvoiceDTO updatedInvoice = invoiceService.updateInvoice(id, request);
            logger.info("Invoice updated successfully with ID: {}", id);
            
            return ResponseEntity.ok(
                RestResponse.<ResInvoiceDTO>builder()
                    .statusCode(200)
                    .message("Cập nhật hóa đơn thành công")
                    .data(updatedInvoice)
                    .build());
                    
        } catch (IllegalArgumentException e) {
            logger.warn("Validation error updating invoice ID: {}, Error: {}", id, e.getMessage());
            return ResponseEntity.badRequest()
                .body(RestResponse.<ResInvoiceDTO>builder()
                    .statusCode(400)
                    .error("VALIDATION_ERROR")
                    .message(e.getMessage())
                    .build());
        } catch (Exception e) {
            logger.error("Error updating invoice with ID: {}", id, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(RestResponse.<ResInvoiceDTO>builder()
                    .statusCode(500)
                    .message("Internal server error")
                    .build());
        }
    }
}
